// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'call_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AppLifecycleStateChanged {
  AppLifecycleState get state => throw _privateConstructorUsedError;
}

/// @nodoc

class _$_AppLifecycleStateChangedImpl
    with DiagnosticableTreeMixin
    implements __AppLifecycleStateChanged {
  const _$_AppLifecycleStateChangedImpl(this.state);

  @override
  final AppLifecycleState state;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_AppLifecycleStateChanged(state: $state)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_AppLifecycleStateChanged'))
      ..add(DiagnosticsProperty('state', state));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppLifecycleStateChangedImpl &&
            (identical(other.state, state) || other.state == state));
  }

  @override
  int get hashCode => Object.hash(runtimeType, state);
}

abstract class __AppLifecycleStateChanged implements _AppLifecycleStateChanged {
  const factory __AppLifecycleStateChanged(final AppLifecycleState state) =
      _$_AppLifecycleStateChangedImpl;

  @override
  AppLifecycleState get state;
}

/// @nodoc
mixin _$ConnectivityResultChanged {
  ConnectivityResult get result => throw _privateConstructorUsedError;
}

/// @nodoc

class _$_ConnectivityResultChangedImpl
    with DiagnosticableTreeMixin
    implements __ConnectivityResultChanged {
  const _$_ConnectivityResultChangedImpl(this.result);

  @override
  final ConnectivityResult result;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_ConnectivityResultChanged(result: $result)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_ConnectivityResultChanged'))
      ..add(DiagnosticsProperty('result', result));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ConnectivityResultChangedImpl &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);
}

abstract class __ConnectivityResultChanged
    implements _ConnectivityResultChanged {
  const factory __ConnectivityResultChanged(final ConnectivityResult result) =
      _$_ConnectivityResultChangedImpl;

  @override
  ConnectivityResult get result;
}

/// @nodoc
mixin _$NavigatorMediaDevicesChange {}

/// @nodoc

class _$_NavigatorMediaDevicesChangeImpl
    with DiagnosticableTreeMixin
    implements __NavigatorMediaDevicesChange {
  const _$_NavigatorMediaDevicesChangeImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_NavigatorMediaDevicesChange()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', '_NavigatorMediaDevicesChange'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NavigatorMediaDevicesChangeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class __NavigatorMediaDevicesChange
    implements _NavigatorMediaDevicesChange {
  const factory __NavigatorMediaDevicesChange() =
      _$_NavigatorMediaDevicesChangeImpl;
}

/// @nodoc
mixin _$SignalingClientEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connectInitiated,
    required TResult Function() disconnectInitiated,
    required TResult Function(int? code, String? reason) disconnected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connectInitiated,
    TResult? Function()? disconnectInitiated,
    TResult? Function(int? code, String? reason)? disconnected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connectInitiated,
    TResult Function()? disconnectInitiated,
    TResult Function(int? code, String? reason)? disconnected,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SignalingClientEventConnectInitiated value)
        connectInitiated,
    required TResult Function(_SignalingClientEventDisconnectInitiated value)
        disconnectInitiated,
    required TResult Function(_SignalingClientEventDisconnected value)
        disconnected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SignalingClientEventConnectInitiated value)?
        connectInitiated,
    TResult? Function(_SignalingClientEventDisconnectInitiated value)?
        disconnectInitiated,
    TResult? Function(_SignalingClientEventDisconnected value)? disconnected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SignalingClientEventConnectInitiated value)?
        connectInitiated,
    TResult Function(_SignalingClientEventDisconnectInitiated value)?
        disconnectInitiated,
    TResult Function(_SignalingClientEventDisconnected value)? disconnected,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc

class _$SignalingClientEventConnectInitiatedImpl
    with DiagnosticableTreeMixin
    implements _SignalingClientEventConnectInitiated {
  const _$SignalingClientEventConnectInitiatedImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_SignalingClientEvent.connectInitiated()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(
        DiagnosticsProperty('type', '_SignalingClientEvent.connectInitiated'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SignalingClientEventConnectInitiatedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connectInitiated,
    required TResult Function() disconnectInitiated,
    required TResult Function(int? code, String? reason) disconnected,
  }) {
    return connectInitiated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connectInitiated,
    TResult? Function()? disconnectInitiated,
    TResult? Function(int? code, String? reason)? disconnected,
  }) {
    return connectInitiated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connectInitiated,
    TResult Function()? disconnectInitiated,
    TResult Function(int? code, String? reason)? disconnected,
    required TResult orElse(),
  }) {
    if (connectInitiated != null) {
      return connectInitiated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SignalingClientEventConnectInitiated value)
        connectInitiated,
    required TResult Function(_SignalingClientEventDisconnectInitiated value)
        disconnectInitiated,
    required TResult Function(_SignalingClientEventDisconnected value)
        disconnected,
  }) {
    return connectInitiated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SignalingClientEventConnectInitiated value)?
        connectInitiated,
    TResult? Function(_SignalingClientEventDisconnectInitiated value)?
        disconnectInitiated,
    TResult? Function(_SignalingClientEventDisconnected value)? disconnected,
  }) {
    return connectInitiated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SignalingClientEventConnectInitiated value)?
        connectInitiated,
    TResult Function(_SignalingClientEventDisconnectInitiated value)?
        disconnectInitiated,
    TResult Function(_SignalingClientEventDisconnected value)? disconnected,
    required TResult orElse(),
  }) {
    if (connectInitiated != null) {
      return connectInitiated(this);
    }
    return orElse();
  }
}

abstract class _SignalingClientEventConnectInitiated
    implements _SignalingClientEvent {
  const factory _SignalingClientEventConnectInitiated() =
      _$SignalingClientEventConnectInitiatedImpl;
}

/// @nodoc

class _$SignalingClientEventDisconnectInitiatedImpl
    with DiagnosticableTreeMixin
    implements _SignalingClientEventDisconnectInitiated {
  const _$SignalingClientEventDisconnectInitiatedImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_SignalingClientEvent.disconnectInitiated()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty(
        'type', '_SignalingClientEvent.disconnectInitiated'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SignalingClientEventDisconnectInitiatedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connectInitiated,
    required TResult Function() disconnectInitiated,
    required TResult Function(int? code, String? reason) disconnected,
  }) {
    return disconnectInitiated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connectInitiated,
    TResult? Function()? disconnectInitiated,
    TResult? Function(int? code, String? reason)? disconnected,
  }) {
    return disconnectInitiated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connectInitiated,
    TResult Function()? disconnectInitiated,
    TResult Function(int? code, String? reason)? disconnected,
    required TResult orElse(),
  }) {
    if (disconnectInitiated != null) {
      return disconnectInitiated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SignalingClientEventConnectInitiated value)
        connectInitiated,
    required TResult Function(_SignalingClientEventDisconnectInitiated value)
        disconnectInitiated,
    required TResult Function(_SignalingClientEventDisconnected value)
        disconnected,
  }) {
    return disconnectInitiated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SignalingClientEventConnectInitiated value)?
        connectInitiated,
    TResult? Function(_SignalingClientEventDisconnectInitiated value)?
        disconnectInitiated,
    TResult? Function(_SignalingClientEventDisconnected value)? disconnected,
  }) {
    return disconnectInitiated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SignalingClientEventConnectInitiated value)?
        connectInitiated,
    TResult Function(_SignalingClientEventDisconnectInitiated value)?
        disconnectInitiated,
    TResult Function(_SignalingClientEventDisconnected value)? disconnected,
    required TResult orElse(),
  }) {
    if (disconnectInitiated != null) {
      return disconnectInitiated(this);
    }
    return orElse();
  }
}

abstract class _SignalingClientEventDisconnectInitiated
    implements _SignalingClientEvent {
  const factory _SignalingClientEventDisconnectInitiated() =
      _$SignalingClientEventDisconnectInitiatedImpl;
}

/// @nodoc

class _$SignalingClientEventDisconnectedImpl
    with DiagnosticableTreeMixin
    implements _SignalingClientEventDisconnected {
  const _$SignalingClientEventDisconnectedImpl(this.code, this.reason);

  @override
  final int? code;
  @override
  final String? reason;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_SignalingClientEvent.disconnected(code: $code, reason: $reason)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_SignalingClientEvent.disconnected'))
      ..add(DiagnosticsProperty('code', code))
      ..add(DiagnosticsProperty('reason', reason));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SignalingClientEventDisconnectedImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @override
  int get hashCode => Object.hash(runtimeType, code, reason);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connectInitiated,
    required TResult Function() disconnectInitiated,
    required TResult Function(int? code, String? reason) disconnected,
  }) {
    return disconnected(code, reason);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connectInitiated,
    TResult? Function()? disconnectInitiated,
    TResult? Function(int? code, String? reason)? disconnected,
  }) {
    return disconnected?.call(code, reason);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connectInitiated,
    TResult Function()? disconnectInitiated,
    TResult Function(int? code, String? reason)? disconnected,
    required TResult orElse(),
  }) {
    if (disconnected != null) {
      return disconnected(code, reason);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SignalingClientEventConnectInitiated value)
        connectInitiated,
    required TResult Function(_SignalingClientEventDisconnectInitiated value)
        disconnectInitiated,
    required TResult Function(_SignalingClientEventDisconnected value)
        disconnected,
  }) {
    return disconnected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SignalingClientEventConnectInitiated value)?
        connectInitiated,
    TResult? Function(_SignalingClientEventDisconnectInitiated value)?
        disconnectInitiated,
    TResult? Function(_SignalingClientEventDisconnected value)? disconnected,
  }) {
    return disconnected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SignalingClientEventConnectInitiated value)?
        connectInitiated,
    TResult Function(_SignalingClientEventDisconnectInitiated value)?
        disconnectInitiated,
    TResult Function(_SignalingClientEventDisconnected value)? disconnected,
    required TResult orElse(),
  }) {
    if (disconnected != null) {
      return disconnected(this);
    }
    return orElse();
  }
}

abstract class _SignalingClientEventDisconnected
    implements _SignalingClientEvent {
  const factory _SignalingClientEventDisconnected(
          final int? code, final String? reason) =
      _$SignalingClientEventDisconnectedImpl;

  int? get code;
  String? get reason;
}

/// @nodoc
mixin _$HandshakeSignalingEvent {
  int get linesCount => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int linesCount) state,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int linesCount)? state,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int linesCount)? state,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HandshakeSignalingEventState value) state,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_HandshakeSignalingEventState value)? state,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HandshakeSignalingEventState value)? state,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc

class _$HandshakeSignalingEventStateImpl
    with DiagnosticableTreeMixin
    implements _HandshakeSignalingEventState {
  const _$HandshakeSignalingEventStateImpl({required this.linesCount});

  @override
  final int linesCount;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_HandshakeSignalingEvent.state(linesCount: $linesCount)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_HandshakeSignalingEvent.state'))
      ..add(DiagnosticsProperty('linesCount', linesCount));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HandshakeSignalingEventStateImpl &&
            (identical(other.linesCount, linesCount) ||
                other.linesCount == linesCount));
  }

  @override
  int get hashCode => Object.hash(runtimeType, linesCount);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int linesCount) state,
  }) {
    return state(linesCount);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int linesCount)? state,
  }) {
    return state?.call(linesCount);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int linesCount)? state,
    required TResult orElse(),
  }) {
    if (state != null) {
      return state(linesCount);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HandshakeSignalingEventState value) state,
  }) {
    return state(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_HandshakeSignalingEventState value)? state,
  }) {
    return state?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HandshakeSignalingEventState value)? state,
    required TResult orElse(),
  }) {
    if (state != null) {
      return state(this);
    }
    return orElse();
  }
}

abstract class _HandshakeSignalingEventState
    implements _HandshakeSignalingEvent {
  const factory _HandshakeSignalingEventState({required final int linesCount}) =
      _$HandshakeSignalingEventStateImpl;

  @override
  int get linesCount;
}

/// @nodoc
mixin _$CallSignalingEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        incoming,
    required TResult Function(int line, CallIdValue callId) ringing,
    required TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)
        progress,
    required TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)
        accepted,
    required TResult Function(
            int line, CallIdValue callId, int code, String reason)
        hangup,
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        updating,
    required TResult Function(int line, CallIdValue callId) updated,
    required TResult Function() unregistered,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult? Function(int line, CallIdValue callId)? ringing,
    TResult? Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult? Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult? Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult? Function(int line, CallIdValue callId)? updated,
    TResult? Function()? unregistered,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult Function(int line, CallIdValue callId)? ringing,
    TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult Function(int line, CallIdValue callId)? updated,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallSignalingEventIncoming value) incoming,
    required TResult Function(_CallSignalingEventRinging value) ringing,
    required TResult Function(_CallSignalingEventProgress value) progress,
    required TResult Function(_CallSignalingEventAccepted value) accepted,
    required TResult Function(_CallSignalingEventHangup value) hangup,
    required TResult Function(_CallSignalingEventUpdating value) updating,
    required TResult Function(_CallSignalingEventUpdated value) updated,
    required TResult Function(_CallSignalingEventUnregistered value)
        unregistered,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallSignalingEventIncoming value)? incoming,
    TResult? Function(_CallSignalingEventRinging value)? ringing,
    TResult? Function(_CallSignalingEventProgress value)? progress,
    TResult? Function(_CallSignalingEventAccepted value)? accepted,
    TResult? Function(_CallSignalingEventHangup value)? hangup,
    TResult? Function(_CallSignalingEventUpdating value)? updating,
    TResult? Function(_CallSignalingEventUpdated value)? updated,
    TResult? Function(_CallSignalingEventUnregistered value)? unregistered,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallSignalingEventIncoming value)? incoming,
    TResult Function(_CallSignalingEventRinging value)? ringing,
    TResult Function(_CallSignalingEventProgress value)? progress,
    TResult Function(_CallSignalingEventAccepted value)? accepted,
    TResult Function(_CallSignalingEventHangup value)? hangup,
    TResult Function(_CallSignalingEventUpdating value)? updating,
    TResult Function(_CallSignalingEventUpdated value)? updated,
    TResult Function(_CallSignalingEventUnregistered value)? unregistered,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc

class _$CallSignalingEventIncomingImpl
    with DiagnosticableTreeMixin
    implements _CallSignalingEventIncoming {
  const _$CallSignalingEventIncomingImpl(
      {required this.line,
      required this.callId,
      required this.callee,
      required this.caller,
      this.callerDisplayName,
      this.referredBy,
      this.replaceCallId,
      this.isFocus,
      this.jsep});

  @override
  final int line;
  @override
  final CallIdValue callId;
  @override
  final String callee;
  @override
  final String caller;
  @override
  final String? callerDisplayName;
  @override
  final String? referredBy;
  @override
  final String? replaceCallId;
  @override
  final bool? isFocus;
  @override
  final JsepValue? jsep;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallSignalingEvent.incoming(line: $line, callId: $callId, callee: $callee, caller: $caller, callerDisplayName: $callerDisplayName, referredBy: $referredBy, replaceCallId: $replaceCallId, isFocus: $isFocus, jsep: $jsep)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallSignalingEvent.incoming'))
      ..add(DiagnosticsProperty('line', line))
      ..add(DiagnosticsProperty('callId', callId))
      ..add(DiagnosticsProperty('callee', callee))
      ..add(DiagnosticsProperty('caller', caller))
      ..add(DiagnosticsProperty('callerDisplayName', callerDisplayName))
      ..add(DiagnosticsProperty('referredBy', referredBy))
      ..add(DiagnosticsProperty('replaceCallId', replaceCallId))
      ..add(DiagnosticsProperty('isFocus', isFocus))
      ..add(DiagnosticsProperty('jsep', jsep));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallSignalingEventIncomingImpl &&
            (identical(other.line, line) || other.line == line) &&
            (identical(other.callId, callId) || other.callId == callId) &&
            (identical(other.callee, callee) || other.callee == callee) &&
            (identical(other.caller, caller) || other.caller == caller) &&
            (identical(other.callerDisplayName, callerDisplayName) ||
                other.callerDisplayName == callerDisplayName) &&
            (identical(other.referredBy, referredBy) ||
                other.referredBy == referredBy) &&
            (identical(other.replaceCallId, replaceCallId) ||
                other.replaceCallId == replaceCallId) &&
            (identical(other.isFocus, isFocus) || other.isFocus == isFocus) &&
            (identical(other.jsep, jsep) || other.jsep == jsep));
  }

  @override
  int get hashCode => Object.hash(runtimeType, line, callId, callee, caller,
      callerDisplayName, referredBy, replaceCallId, isFocus, jsep);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        incoming,
    required TResult Function(int line, CallIdValue callId) ringing,
    required TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)
        progress,
    required TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)
        accepted,
    required TResult Function(
            int line, CallIdValue callId, int code, String reason)
        hangup,
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        updating,
    required TResult Function(int line, CallIdValue callId) updated,
    required TResult Function() unregistered,
  }) {
    return incoming(line, callId, callee, caller, callerDisplayName, referredBy,
        replaceCallId, isFocus, jsep);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult? Function(int line, CallIdValue callId)? ringing,
    TResult? Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult? Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult? Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult? Function(int line, CallIdValue callId)? updated,
    TResult? Function()? unregistered,
  }) {
    return incoming?.call(line, callId, callee, caller, callerDisplayName,
        referredBy, replaceCallId, isFocus, jsep);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult Function(int line, CallIdValue callId)? ringing,
    TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult Function(int line, CallIdValue callId)? updated,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) {
    if (incoming != null) {
      return incoming(line, callId, callee, caller, callerDisplayName,
          referredBy, replaceCallId, isFocus, jsep);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallSignalingEventIncoming value) incoming,
    required TResult Function(_CallSignalingEventRinging value) ringing,
    required TResult Function(_CallSignalingEventProgress value) progress,
    required TResult Function(_CallSignalingEventAccepted value) accepted,
    required TResult Function(_CallSignalingEventHangup value) hangup,
    required TResult Function(_CallSignalingEventUpdating value) updating,
    required TResult Function(_CallSignalingEventUpdated value) updated,
    required TResult Function(_CallSignalingEventUnregistered value)
        unregistered,
  }) {
    return incoming(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallSignalingEventIncoming value)? incoming,
    TResult? Function(_CallSignalingEventRinging value)? ringing,
    TResult? Function(_CallSignalingEventProgress value)? progress,
    TResult? Function(_CallSignalingEventAccepted value)? accepted,
    TResult? Function(_CallSignalingEventHangup value)? hangup,
    TResult? Function(_CallSignalingEventUpdating value)? updating,
    TResult? Function(_CallSignalingEventUpdated value)? updated,
    TResult? Function(_CallSignalingEventUnregistered value)? unregistered,
  }) {
    return incoming?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallSignalingEventIncoming value)? incoming,
    TResult Function(_CallSignalingEventRinging value)? ringing,
    TResult Function(_CallSignalingEventProgress value)? progress,
    TResult Function(_CallSignalingEventAccepted value)? accepted,
    TResult Function(_CallSignalingEventHangup value)? hangup,
    TResult Function(_CallSignalingEventUpdating value)? updating,
    TResult Function(_CallSignalingEventUpdated value)? updated,
    TResult Function(_CallSignalingEventUnregistered value)? unregistered,
    required TResult orElse(),
  }) {
    if (incoming != null) {
      return incoming(this);
    }
    return orElse();
  }
}

abstract class _CallSignalingEventIncoming implements _CallSignalingEvent {
  const factory _CallSignalingEventIncoming(
      {required final int line,
      required final CallIdValue callId,
      required final String callee,
      required final String caller,
      final String? callerDisplayName,
      final String? referredBy,
      final String? replaceCallId,
      final bool? isFocus,
      final JsepValue? jsep}) = _$CallSignalingEventIncomingImpl;

  int get line;
  CallIdValue get callId;
  String get callee;
  String get caller;
  String? get callerDisplayName;
  String? get referredBy;
  String? get replaceCallId;
  bool? get isFocus;
  JsepValue? get jsep;
}

/// @nodoc

class _$CallSignalingEventRingingImpl
    with DiagnosticableTreeMixin
    implements _CallSignalingEventRinging {
  const _$CallSignalingEventRingingImpl(
      {required this.line, required this.callId});

  @override
  final int line;
  @override
  final CallIdValue callId;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallSignalingEvent.ringing(line: $line, callId: $callId)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallSignalingEvent.ringing'))
      ..add(DiagnosticsProperty('line', line))
      ..add(DiagnosticsProperty('callId', callId));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallSignalingEventRingingImpl &&
            (identical(other.line, line) || other.line == line) &&
            (identical(other.callId, callId) || other.callId == callId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, line, callId);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        incoming,
    required TResult Function(int line, CallIdValue callId) ringing,
    required TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)
        progress,
    required TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)
        accepted,
    required TResult Function(
            int line, CallIdValue callId, int code, String reason)
        hangup,
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        updating,
    required TResult Function(int line, CallIdValue callId) updated,
    required TResult Function() unregistered,
  }) {
    return ringing(line, callId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult? Function(int line, CallIdValue callId)? ringing,
    TResult? Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult? Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult? Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult? Function(int line, CallIdValue callId)? updated,
    TResult? Function()? unregistered,
  }) {
    return ringing?.call(line, callId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult Function(int line, CallIdValue callId)? ringing,
    TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult Function(int line, CallIdValue callId)? updated,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) {
    if (ringing != null) {
      return ringing(line, callId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallSignalingEventIncoming value) incoming,
    required TResult Function(_CallSignalingEventRinging value) ringing,
    required TResult Function(_CallSignalingEventProgress value) progress,
    required TResult Function(_CallSignalingEventAccepted value) accepted,
    required TResult Function(_CallSignalingEventHangup value) hangup,
    required TResult Function(_CallSignalingEventUpdating value) updating,
    required TResult Function(_CallSignalingEventUpdated value) updated,
    required TResult Function(_CallSignalingEventUnregistered value)
        unregistered,
  }) {
    return ringing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallSignalingEventIncoming value)? incoming,
    TResult? Function(_CallSignalingEventRinging value)? ringing,
    TResult? Function(_CallSignalingEventProgress value)? progress,
    TResult? Function(_CallSignalingEventAccepted value)? accepted,
    TResult? Function(_CallSignalingEventHangup value)? hangup,
    TResult? Function(_CallSignalingEventUpdating value)? updating,
    TResult? Function(_CallSignalingEventUpdated value)? updated,
    TResult? Function(_CallSignalingEventUnregistered value)? unregistered,
  }) {
    return ringing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallSignalingEventIncoming value)? incoming,
    TResult Function(_CallSignalingEventRinging value)? ringing,
    TResult Function(_CallSignalingEventProgress value)? progress,
    TResult Function(_CallSignalingEventAccepted value)? accepted,
    TResult Function(_CallSignalingEventHangup value)? hangup,
    TResult Function(_CallSignalingEventUpdating value)? updating,
    TResult Function(_CallSignalingEventUpdated value)? updated,
    TResult Function(_CallSignalingEventUnregistered value)? unregistered,
    required TResult orElse(),
  }) {
    if (ringing != null) {
      return ringing(this);
    }
    return orElse();
  }
}

abstract class _CallSignalingEventRinging implements _CallSignalingEvent {
  const factory _CallSignalingEventRinging(
      {required final int line,
      required final CallIdValue callId}) = _$CallSignalingEventRingingImpl;

  int get line;
  CallIdValue get callId;
}

/// @nodoc

class _$CallSignalingEventProgressImpl
    with DiagnosticableTreeMixin
    implements _CallSignalingEventProgress {
  const _$CallSignalingEventProgressImpl(
      {required this.line,
      required this.callId,
      required this.callee,
      this.jsep});

  @override
  final int line;
  @override
  final CallIdValue callId;
  @override
  final String callee;
  @override
  final JsepValue? jsep;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallSignalingEvent.progress(line: $line, callId: $callId, callee: $callee, jsep: $jsep)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallSignalingEvent.progress'))
      ..add(DiagnosticsProperty('line', line))
      ..add(DiagnosticsProperty('callId', callId))
      ..add(DiagnosticsProperty('callee', callee))
      ..add(DiagnosticsProperty('jsep', jsep));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallSignalingEventProgressImpl &&
            (identical(other.line, line) || other.line == line) &&
            (identical(other.callId, callId) || other.callId == callId) &&
            (identical(other.callee, callee) || other.callee == callee) &&
            (identical(other.jsep, jsep) || other.jsep == jsep));
  }

  @override
  int get hashCode => Object.hash(runtimeType, line, callId, callee, jsep);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        incoming,
    required TResult Function(int line, CallIdValue callId) ringing,
    required TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)
        progress,
    required TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)
        accepted,
    required TResult Function(
            int line, CallIdValue callId, int code, String reason)
        hangup,
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        updating,
    required TResult Function(int line, CallIdValue callId) updated,
    required TResult Function() unregistered,
  }) {
    return progress(line, callId, callee, jsep);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult? Function(int line, CallIdValue callId)? ringing,
    TResult? Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult? Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult? Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult? Function(int line, CallIdValue callId)? updated,
    TResult? Function()? unregistered,
  }) {
    return progress?.call(line, callId, callee, jsep);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult Function(int line, CallIdValue callId)? ringing,
    TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult Function(int line, CallIdValue callId)? updated,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) {
    if (progress != null) {
      return progress(line, callId, callee, jsep);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallSignalingEventIncoming value) incoming,
    required TResult Function(_CallSignalingEventRinging value) ringing,
    required TResult Function(_CallSignalingEventProgress value) progress,
    required TResult Function(_CallSignalingEventAccepted value) accepted,
    required TResult Function(_CallSignalingEventHangup value) hangup,
    required TResult Function(_CallSignalingEventUpdating value) updating,
    required TResult Function(_CallSignalingEventUpdated value) updated,
    required TResult Function(_CallSignalingEventUnregistered value)
        unregistered,
  }) {
    return progress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallSignalingEventIncoming value)? incoming,
    TResult? Function(_CallSignalingEventRinging value)? ringing,
    TResult? Function(_CallSignalingEventProgress value)? progress,
    TResult? Function(_CallSignalingEventAccepted value)? accepted,
    TResult? Function(_CallSignalingEventHangup value)? hangup,
    TResult? Function(_CallSignalingEventUpdating value)? updating,
    TResult? Function(_CallSignalingEventUpdated value)? updated,
    TResult? Function(_CallSignalingEventUnregistered value)? unregistered,
  }) {
    return progress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallSignalingEventIncoming value)? incoming,
    TResult Function(_CallSignalingEventRinging value)? ringing,
    TResult Function(_CallSignalingEventProgress value)? progress,
    TResult Function(_CallSignalingEventAccepted value)? accepted,
    TResult Function(_CallSignalingEventHangup value)? hangup,
    TResult Function(_CallSignalingEventUpdating value)? updating,
    TResult Function(_CallSignalingEventUpdated value)? updated,
    TResult Function(_CallSignalingEventUnregistered value)? unregistered,
    required TResult orElse(),
  }) {
    if (progress != null) {
      return progress(this);
    }
    return orElse();
  }
}

abstract class _CallSignalingEventProgress implements _CallSignalingEvent {
  const factory _CallSignalingEventProgress(
      {required final int line,
      required final CallIdValue callId,
      required final String callee,
      final JsepValue? jsep}) = _$CallSignalingEventProgressImpl;

  int get line;
  CallIdValue get callId;
  String get callee;
  JsepValue? get jsep;
}

/// @nodoc

class _$CallSignalingEventAcceptedImpl
    with DiagnosticableTreeMixin
    implements _CallSignalingEventAccepted {
  const _$CallSignalingEventAcceptedImpl(
      {required this.line, required this.callId, this.callee, this.jsep});

  @override
  final int line;
  @override
  final CallIdValue callId;
  @override
  final String? callee;
  @override
  final JsepValue? jsep;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallSignalingEvent.accepted(line: $line, callId: $callId, callee: $callee, jsep: $jsep)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallSignalingEvent.accepted'))
      ..add(DiagnosticsProperty('line', line))
      ..add(DiagnosticsProperty('callId', callId))
      ..add(DiagnosticsProperty('callee', callee))
      ..add(DiagnosticsProperty('jsep', jsep));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallSignalingEventAcceptedImpl &&
            (identical(other.line, line) || other.line == line) &&
            (identical(other.callId, callId) || other.callId == callId) &&
            (identical(other.callee, callee) || other.callee == callee) &&
            (identical(other.jsep, jsep) || other.jsep == jsep));
  }

  @override
  int get hashCode => Object.hash(runtimeType, line, callId, callee, jsep);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        incoming,
    required TResult Function(int line, CallIdValue callId) ringing,
    required TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)
        progress,
    required TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)
        accepted,
    required TResult Function(
            int line, CallIdValue callId, int code, String reason)
        hangup,
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        updating,
    required TResult Function(int line, CallIdValue callId) updated,
    required TResult Function() unregistered,
  }) {
    return accepted(line, callId, callee, jsep);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult? Function(int line, CallIdValue callId)? ringing,
    TResult? Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult? Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult? Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult? Function(int line, CallIdValue callId)? updated,
    TResult? Function()? unregistered,
  }) {
    return accepted?.call(line, callId, callee, jsep);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult Function(int line, CallIdValue callId)? ringing,
    TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult Function(int line, CallIdValue callId)? updated,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) {
    if (accepted != null) {
      return accepted(line, callId, callee, jsep);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallSignalingEventIncoming value) incoming,
    required TResult Function(_CallSignalingEventRinging value) ringing,
    required TResult Function(_CallSignalingEventProgress value) progress,
    required TResult Function(_CallSignalingEventAccepted value) accepted,
    required TResult Function(_CallSignalingEventHangup value) hangup,
    required TResult Function(_CallSignalingEventUpdating value) updating,
    required TResult Function(_CallSignalingEventUpdated value) updated,
    required TResult Function(_CallSignalingEventUnregistered value)
        unregistered,
  }) {
    return accepted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallSignalingEventIncoming value)? incoming,
    TResult? Function(_CallSignalingEventRinging value)? ringing,
    TResult? Function(_CallSignalingEventProgress value)? progress,
    TResult? Function(_CallSignalingEventAccepted value)? accepted,
    TResult? Function(_CallSignalingEventHangup value)? hangup,
    TResult? Function(_CallSignalingEventUpdating value)? updating,
    TResult? Function(_CallSignalingEventUpdated value)? updated,
    TResult? Function(_CallSignalingEventUnregistered value)? unregistered,
  }) {
    return accepted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallSignalingEventIncoming value)? incoming,
    TResult Function(_CallSignalingEventRinging value)? ringing,
    TResult Function(_CallSignalingEventProgress value)? progress,
    TResult Function(_CallSignalingEventAccepted value)? accepted,
    TResult Function(_CallSignalingEventHangup value)? hangup,
    TResult Function(_CallSignalingEventUpdating value)? updating,
    TResult Function(_CallSignalingEventUpdated value)? updated,
    TResult Function(_CallSignalingEventUnregistered value)? unregistered,
    required TResult orElse(),
  }) {
    if (accepted != null) {
      return accepted(this);
    }
    return orElse();
  }
}

abstract class _CallSignalingEventAccepted implements _CallSignalingEvent {
  const factory _CallSignalingEventAccepted(
      {required final int line,
      required final CallIdValue callId,
      final String? callee,
      final JsepValue? jsep}) = _$CallSignalingEventAcceptedImpl;

  int get line;
  CallIdValue get callId;
  String? get callee;
  JsepValue? get jsep;
}

/// @nodoc

class _$CallSignalingEventHangupImpl
    with DiagnosticableTreeMixin
    implements _CallSignalingEventHangup {
  const _$CallSignalingEventHangupImpl(
      {required this.line,
      required this.callId,
      required this.code,
      required this.reason});

  @override
  final int line;
  @override
  final CallIdValue callId;
  @override
  final int code;
  @override
  final String reason;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallSignalingEvent.hangup(line: $line, callId: $callId, code: $code, reason: $reason)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallSignalingEvent.hangup'))
      ..add(DiagnosticsProperty('line', line))
      ..add(DiagnosticsProperty('callId', callId))
      ..add(DiagnosticsProperty('code', code))
      ..add(DiagnosticsProperty('reason', reason));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallSignalingEventHangupImpl &&
            (identical(other.line, line) || other.line == line) &&
            (identical(other.callId, callId) || other.callId == callId) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @override
  int get hashCode => Object.hash(runtimeType, line, callId, code, reason);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        incoming,
    required TResult Function(int line, CallIdValue callId) ringing,
    required TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)
        progress,
    required TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)
        accepted,
    required TResult Function(
            int line, CallIdValue callId, int code, String reason)
        hangup,
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        updating,
    required TResult Function(int line, CallIdValue callId) updated,
    required TResult Function() unregistered,
  }) {
    return hangup(line, callId, code, reason);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult? Function(int line, CallIdValue callId)? ringing,
    TResult? Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult? Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult? Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult? Function(int line, CallIdValue callId)? updated,
    TResult? Function()? unregistered,
  }) {
    return hangup?.call(line, callId, code, reason);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult Function(int line, CallIdValue callId)? ringing,
    TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult Function(int line, CallIdValue callId)? updated,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) {
    if (hangup != null) {
      return hangup(line, callId, code, reason);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallSignalingEventIncoming value) incoming,
    required TResult Function(_CallSignalingEventRinging value) ringing,
    required TResult Function(_CallSignalingEventProgress value) progress,
    required TResult Function(_CallSignalingEventAccepted value) accepted,
    required TResult Function(_CallSignalingEventHangup value) hangup,
    required TResult Function(_CallSignalingEventUpdating value) updating,
    required TResult Function(_CallSignalingEventUpdated value) updated,
    required TResult Function(_CallSignalingEventUnregistered value)
        unregistered,
  }) {
    return hangup(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallSignalingEventIncoming value)? incoming,
    TResult? Function(_CallSignalingEventRinging value)? ringing,
    TResult? Function(_CallSignalingEventProgress value)? progress,
    TResult? Function(_CallSignalingEventAccepted value)? accepted,
    TResult? Function(_CallSignalingEventHangup value)? hangup,
    TResult? Function(_CallSignalingEventUpdating value)? updating,
    TResult? Function(_CallSignalingEventUpdated value)? updated,
    TResult? Function(_CallSignalingEventUnregistered value)? unregistered,
  }) {
    return hangup?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallSignalingEventIncoming value)? incoming,
    TResult Function(_CallSignalingEventRinging value)? ringing,
    TResult Function(_CallSignalingEventProgress value)? progress,
    TResult Function(_CallSignalingEventAccepted value)? accepted,
    TResult Function(_CallSignalingEventHangup value)? hangup,
    TResult Function(_CallSignalingEventUpdating value)? updating,
    TResult Function(_CallSignalingEventUpdated value)? updated,
    TResult Function(_CallSignalingEventUnregistered value)? unregistered,
    required TResult orElse(),
  }) {
    if (hangup != null) {
      return hangup(this);
    }
    return orElse();
  }
}

abstract class _CallSignalingEventHangup implements _CallSignalingEvent {
  const factory _CallSignalingEventHangup(
      {required final int line,
      required final CallIdValue callId,
      required final int code,
      required final String reason}) = _$CallSignalingEventHangupImpl;

  int get line;
  CallIdValue get callId;
  int get code;
  String get reason;
}

/// @nodoc

class _$CallSignalingEventUpdatingImpl
    with DiagnosticableTreeMixin
    implements _CallSignalingEventUpdating {
  const _$CallSignalingEventUpdatingImpl(
      {required this.line,
      required this.callId,
      required this.callee,
      required this.caller,
      this.callerDisplayName,
      this.referredBy,
      this.replaceCallId,
      this.isFocus,
      this.jsep});

  @override
  final int line;
  @override
  final CallIdValue callId;
  @override
  final String callee;
  @override
  final String caller;
  @override
  final String? callerDisplayName;
  @override
  final String? referredBy;
  @override
  final String? replaceCallId;
  @override
  final bool? isFocus;
  @override
  final JsepValue? jsep;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallSignalingEvent.updating(line: $line, callId: $callId, callee: $callee, caller: $caller, callerDisplayName: $callerDisplayName, referredBy: $referredBy, replaceCallId: $replaceCallId, isFocus: $isFocus, jsep: $jsep)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallSignalingEvent.updating'))
      ..add(DiagnosticsProperty('line', line))
      ..add(DiagnosticsProperty('callId', callId))
      ..add(DiagnosticsProperty('callee', callee))
      ..add(DiagnosticsProperty('caller', caller))
      ..add(DiagnosticsProperty('callerDisplayName', callerDisplayName))
      ..add(DiagnosticsProperty('referredBy', referredBy))
      ..add(DiagnosticsProperty('replaceCallId', replaceCallId))
      ..add(DiagnosticsProperty('isFocus', isFocus))
      ..add(DiagnosticsProperty('jsep', jsep));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallSignalingEventUpdatingImpl &&
            (identical(other.line, line) || other.line == line) &&
            (identical(other.callId, callId) || other.callId == callId) &&
            (identical(other.callee, callee) || other.callee == callee) &&
            (identical(other.caller, caller) || other.caller == caller) &&
            (identical(other.callerDisplayName, callerDisplayName) ||
                other.callerDisplayName == callerDisplayName) &&
            (identical(other.referredBy, referredBy) ||
                other.referredBy == referredBy) &&
            (identical(other.replaceCallId, replaceCallId) ||
                other.replaceCallId == replaceCallId) &&
            (identical(other.isFocus, isFocus) || other.isFocus == isFocus) &&
            (identical(other.jsep, jsep) || other.jsep == jsep));
  }

  @override
  int get hashCode => Object.hash(runtimeType, line, callId, callee, caller,
      callerDisplayName, referredBy, replaceCallId, isFocus, jsep);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        incoming,
    required TResult Function(int line, CallIdValue callId) ringing,
    required TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)
        progress,
    required TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)
        accepted,
    required TResult Function(
            int line, CallIdValue callId, int code, String reason)
        hangup,
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        updating,
    required TResult Function(int line, CallIdValue callId) updated,
    required TResult Function() unregistered,
  }) {
    return updating(line, callId, callee, caller, callerDisplayName, referredBy,
        replaceCallId, isFocus, jsep);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult? Function(int line, CallIdValue callId)? ringing,
    TResult? Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult? Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult? Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult? Function(int line, CallIdValue callId)? updated,
    TResult? Function()? unregistered,
  }) {
    return updating?.call(line, callId, callee, caller, callerDisplayName,
        referredBy, replaceCallId, isFocus, jsep);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult Function(int line, CallIdValue callId)? ringing,
    TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult Function(int line, CallIdValue callId)? updated,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) {
    if (updating != null) {
      return updating(line, callId, callee, caller, callerDisplayName,
          referredBy, replaceCallId, isFocus, jsep);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallSignalingEventIncoming value) incoming,
    required TResult Function(_CallSignalingEventRinging value) ringing,
    required TResult Function(_CallSignalingEventProgress value) progress,
    required TResult Function(_CallSignalingEventAccepted value) accepted,
    required TResult Function(_CallSignalingEventHangup value) hangup,
    required TResult Function(_CallSignalingEventUpdating value) updating,
    required TResult Function(_CallSignalingEventUpdated value) updated,
    required TResult Function(_CallSignalingEventUnregistered value)
        unregistered,
  }) {
    return updating(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallSignalingEventIncoming value)? incoming,
    TResult? Function(_CallSignalingEventRinging value)? ringing,
    TResult? Function(_CallSignalingEventProgress value)? progress,
    TResult? Function(_CallSignalingEventAccepted value)? accepted,
    TResult? Function(_CallSignalingEventHangup value)? hangup,
    TResult? Function(_CallSignalingEventUpdating value)? updating,
    TResult? Function(_CallSignalingEventUpdated value)? updated,
    TResult? Function(_CallSignalingEventUnregistered value)? unregistered,
  }) {
    return updating?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallSignalingEventIncoming value)? incoming,
    TResult Function(_CallSignalingEventRinging value)? ringing,
    TResult Function(_CallSignalingEventProgress value)? progress,
    TResult Function(_CallSignalingEventAccepted value)? accepted,
    TResult Function(_CallSignalingEventHangup value)? hangup,
    TResult Function(_CallSignalingEventUpdating value)? updating,
    TResult Function(_CallSignalingEventUpdated value)? updated,
    TResult Function(_CallSignalingEventUnregistered value)? unregistered,
    required TResult orElse(),
  }) {
    if (updating != null) {
      return updating(this);
    }
    return orElse();
  }
}

abstract class _CallSignalingEventUpdating implements _CallSignalingEvent {
  const factory _CallSignalingEventUpdating(
      {required final int line,
      required final CallIdValue callId,
      required final String callee,
      required final String caller,
      final String? callerDisplayName,
      final String? referredBy,
      final String? replaceCallId,
      final bool? isFocus,
      final JsepValue? jsep}) = _$CallSignalingEventUpdatingImpl;

  int get line;
  CallIdValue get callId;
  String get callee;
  String get caller;
  String? get callerDisplayName;
  String? get referredBy;
  String? get replaceCallId;
  bool? get isFocus;
  JsepValue? get jsep;
}

/// @nodoc

class _$CallSignalingEventUpdatedImpl
    with DiagnosticableTreeMixin
    implements _CallSignalingEventUpdated {
  const _$CallSignalingEventUpdatedImpl(
      {required this.line, required this.callId});

  @override
  final int line;
  @override
  final CallIdValue callId;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallSignalingEvent.updated(line: $line, callId: $callId)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallSignalingEvent.updated'))
      ..add(DiagnosticsProperty('line', line))
      ..add(DiagnosticsProperty('callId', callId));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallSignalingEventUpdatedImpl &&
            (identical(other.line, line) || other.line == line) &&
            (identical(other.callId, callId) || other.callId == callId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, line, callId);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        incoming,
    required TResult Function(int line, CallIdValue callId) ringing,
    required TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)
        progress,
    required TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)
        accepted,
    required TResult Function(
            int line, CallIdValue callId, int code, String reason)
        hangup,
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        updating,
    required TResult Function(int line, CallIdValue callId) updated,
    required TResult Function() unregistered,
  }) {
    return updated(line, callId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult? Function(int line, CallIdValue callId)? ringing,
    TResult? Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult? Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult? Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult? Function(int line, CallIdValue callId)? updated,
    TResult? Function()? unregistered,
  }) {
    return updated?.call(line, callId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult Function(int line, CallIdValue callId)? ringing,
    TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult Function(int line, CallIdValue callId)? updated,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) {
    if (updated != null) {
      return updated(line, callId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallSignalingEventIncoming value) incoming,
    required TResult Function(_CallSignalingEventRinging value) ringing,
    required TResult Function(_CallSignalingEventProgress value) progress,
    required TResult Function(_CallSignalingEventAccepted value) accepted,
    required TResult Function(_CallSignalingEventHangup value) hangup,
    required TResult Function(_CallSignalingEventUpdating value) updating,
    required TResult Function(_CallSignalingEventUpdated value) updated,
    required TResult Function(_CallSignalingEventUnregistered value)
        unregistered,
  }) {
    return updated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallSignalingEventIncoming value)? incoming,
    TResult? Function(_CallSignalingEventRinging value)? ringing,
    TResult? Function(_CallSignalingEventProgress value)? progress,
    TResult? Function(_CallSignalingEventAccepted value)? accepted,
    TResult? Function(_CallSignalingEventHangup value)? hangup,
    TResult? Function(_CallSignalingEventUpdating value)? updating,
    TResult? Function(_CallSignalingEventUpdated value)? updated,
    TResult? Function(_CallSignalingEventUnregistered value)? unregistered,
  }) {
    return updated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallSignalingEventIncoming value)? incoming,
    TResult Function(_CallSignalingEventRinging value)? ringing,
    TResult Function(_CallSignalingEventProgress value)? progress,
    TResult Function(_CallSignalingEventAccepted value)? accepted,
    TResult Function(_CallSignalingEventHangup value)? hangup,
    TResult Function(_CallSignalingEventUpdating value)? updating,
    TResult Function(_CallSignalingEventUpdated value)? updated,
    TResult Function(_CallSignalingEventUnregistered value)? unregistered,
    required TResult orElse(),
  }) {
    if (updated != null) {
      return updated(this);
    }
    return orElse();
  }
}

abstract class _CallSignalingEventUpdated implements _CallSignalingEvent {
  const factory _CallSignalingEventUpdated(
      {required final int line,
      required final CallIdValue callId}) = _$CallSignalingEventUpdatedImpl;

  int get line;
  CallIdValue get callId;
}

/// @nodoc

class _$CallSignalingEventUnregisteredImpl
    with DiagnosticableTreeMixin
    implements _CallSignalingEventUnregistered {
  const _$CallSignalingEventUnregisteredImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallSignalingEvent.unregistered()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', '_CallSignalingEvent.unregistered'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallSignalingEventUnregisteredImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        incoming,
    required TResult Function(int line, CallIdValue callId) ringing,
    required TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)
        progress,
    required TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)
        accepted,
    required TResult Function(
            int line, CallIdValue callId, int code, String reason)
        hangup,
    required TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)
        updating,
    required TResult Function(int line, CallIdValue callId) updated,
    required TResult Function() unregistered,
  }) {
    return unregistered();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult? Function(int line, CallIdValue callId)? ringing,
    TResult? Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult? Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult? Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult? Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult? Function(int line, CallIdValue callId)? updated,
    TResult? Function()? unregistered,
  }) {
    return unregistered?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        incoming,
    TResult Function(int line, CallIdValue callId)? ringing,
    TResult Function(
            int line, CallIdValue callId, String callee, JsepValue? jsep)?
        progress,
    TResult Function(
            int line, CallIdValue callId, String? callee, JsepValue? jsep)?
        accepted,
    TResult Function(int line, CallIdValue callId, int code, String reason)?
        hangup,
    TResult Function(
            int line,
            CallIdValue callId,
            String callee,
            String caller,
            String? callerDisplayName,
            String? referredBy,
            String? replaceCallId,
            bool? isFocus,
            JsepValue? jsep)?
        updating,
    TResult Function(int line, CallIdValue callId)? updated,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) {
    if (unregistered != null) {
      return unregistered();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallSignalingEventIncoming value) incoming,
    required TResult Function(_CallSignalingEventRinging value) ringing,
    required TResult Function(_CallSignalingEventProgress value) progress,
    required TResult Function(_CallSignalingEventAccepted value) accepted,
    required TResult Function(_CallSignalingEventHangup value) hangup,
    required TResult Function(_CallSignalingEventUpdating value) updating,
    required TResult Function(_CallSignalingEventUpdated value) updated,
    required TResult Function(_CallSignalingEventUnregistered value)
        unregistered,
  }) {
    return unregistered(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallSignalingEventIncoming value)? incoming,
    TResult? Function(_CallSignalingEventRinging value)? ringing,
    TResult? Function(_CallSignalingEventProgress value)? progress,
    TResult? Function(_CallSignalingEventAccepted value)? accepted,
    TResult? Function(_CallSignalingEventHangup value)? hangup,
    TResult? Function(_CallSignalingEventUpdating value)? updating,
    TResult? Function(_CallSignalingEventUpdated value)? updated,
    TResult? Function(_CallSignalingEventUnregistered value)? unregistered,
  }) {
    return unregistered?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallSignalingEventIncoming value)? incoming,
    TResult Function(_CallSignalingEventRinging value)? ringing,
    TResult Function(_CallSignalingEventProgress value)? progress,
    TResult Function(_CallSignalingEventAccepted value)? accepted,
    TResult Function(_CallSignalingEventHangup value)? hangup,
    TResult Function(_CallSignalingEventUpdating value)? updating,
    TResult Function(_CallSignalingEventUpdated value)? updated,
    TResult Function(_CallSignalingEventUnregistered value)? unregistered,
    required TResult orElse(),
  }) {
    if (unregistered != null) {
      return unregistered(this);
    }
    return orElse();
  }
}

abstract class _CallSignalingEventUnregistered implements _CallSignalingEvent {
  const factory _CallSignalingEventUnregistered() =
      _$CallSignalingEventUnregisteredImpl;
}

/// @nodoc
mixin _$CallPushEvent {
  CallIdValue get callId => throw _privateConstructorUsedError;
  CallkeepHandle get handle => throw _privateConstructorUsedError;
  String? get displayName => throw _privateConstructorUsedError;
  bool get video => throw _privateConstructorUsedError;
  CallkeepIncomingCallError? get error => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CallIdValue callId, CallkeepHandle handle,
            String? displayName, bool video, CallkeepIncomingCallError? error)
        incoming,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CallIdValue callId, CallkeepHandle handle,
            String? displayName, bool video, CallkeepIncomingCallError? error)?
        incoming,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CallIdValue callId, CallkeepHandle handle,
            String? displayName, bool video, CallkeepIncomingCallError? error)?
        incoming,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallPushEventIncoming value) incoming,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallPushEventIncoming value)? incoming,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallPushEventIncoming value)? incoming,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc

class _$CallPushEventIncomingImpl
    with DiagnosticableTreeMixin
    implements _CallPushEventIncoming {
  const _$CallPushEventIncomingImpl(
      {required this.callId,
      required this.handle,
      this.displayName,
      required this.video,
      this.error});

  @override
  final CallIdValue callId;
  @override
  final CallkeepHandle handle;
  @override
  final String? displayName;
  @override
  final bool video;
  @override
  final CallkeepIncomingCallError? error;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallPushEvent.incoming(callId: $callId, handle: $handle, displayName: $displayName, video: $video, error: $error)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallPushEvent.incoming'))
      ..add(DiagnosticsProperty('callId', callId))
      ..add(DiagnosticsProperty('handle', handle))
      ..add(DiagnosticsProperty('displayName', displayName))
      ..add(DiagnosticsProperty('video', video))
      ..add(DiagnosticsProperty('error', error));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallPushEventIncomingImpl &&
            (identical(other.callId, callId) || other.callId == callId) &&
            (identical(other.handle, handle) || other.handle == handle) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.video, video) || other.video == video) &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, callId, handle, displayName, video, error);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CallIdValue callId, CallkeepHandle handle,
            String? displayName, bool video, CallkeepIncomingCallError? error)
        incoming,
  }) {
    return incoming(callId, handle, displayName, video, error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CallIdValue callId, CallkeepHandle handle,
            String? displayName, bool video, CallkeepIncomingCallError? error)?
        incoming,
  }) {
    return incoming?.call(callId, handle, displayName, video, error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CallIdValue callId, CallkeepHandle handle,
            String? displayName, bool video, CallkeepIncomingCallError? error)?
        incoming,
    required TResult orElse(),
  }) {
    if (incoming != null) {
      return incoming(callId, handle, displayName, video, error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallPushEventIncoming value) incoming,
  }) {
    return incoming(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallPushEventIncoming value)? incoming,
  }) {
    return incoming?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallPushEventIncoming value)? incoming,
    required TResult orElse(),
  }) {
    if (incoming != null) {
      return incoming(this);
    }
    return orElse();
  }
}

abstract class _CallPushEventIncoming implements _CallPushEvent {
  const factory _CallPushEventIncoming(
      {required final CallIdValue callId,
      required final CallkeepHandle handle,
      final String? displayName,
      required final bool video,
      final CallkeepIncomingCallError? error}) = _$CallPushEventIncomingImpl;

  @override
  CallIdValue get callId;
  @override
  CallkeepHandle get handle;
  @override
  String? get displayName;
  @override
  bool get video;
  @override
  CallkeepIncomingCallError? get error;
}

/// @nodoc
mixin _$CallControlEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? line, String? generic, String? number,
            String? email, String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
    required TResult Function(UuidValue uuid) cameraSwitched,
    required TResult Function(UuidValue uuid, bool enabled) cameraEnabled,
    required TResult Function(UuidValue uuid, bool enabled) speakerEnabled,
    required TResult Function(UuidValue uuid) failureApproved,
    required TResult Function(UuidValue uuid) blindTransferInitiated,
    required TResult Function(String number) blindTransferred,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
    TResult? Function(UuidValue uuid)? cameraSwitched,
    TResult? Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult? Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult? Function(UuidValue uuid)? failureApproved,
    TResult? Function(UuidValue uuid)? blindTransferInitiated,
    TResult? Function(String number)? blindTransferred,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    TResult Function(UuidValue uuid)? cameraSwitched,
    TResult Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult Function(UuidValue uuid)? failureApproved,
    TResult Function(UuidValue uuid)? blindTransferInitiated,
    TResult Function(String number)? blindTransferred,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallControlEventStarted value) started,
    required TResult Function(_CallControlEventAnswered value) answered,
    required TResult Function(_CallControlEventEnded value) ended,
    required TResult Function(_CallControlEventSetHeld value) setHeld,
    required TResult Function(_CallControlEventSetMuted value) setMuted,
    required TResult Function(_CallControlEventSentDTMF value) sentDTMF,
    required TResult Function(_CallControlEventCameraSwitched value)
        cameraSwitched,
    required TResult Function(_CallControlEventCameraEnabled value)
        cameraEnabled,
    required TResult Function(_CallControlEventSpeakerEnabled value)
        speakerEnabled,
    required TResult Function(_CallControlEventFailureApproved value)
        failureApproved,
    required TResult Function(_CallControlEventBlindTransferInitiated value)
        blindTransferInitiated,
    required TResult Function(_CallControlEventBlindTransferred value)
        blindTransferred,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallControlEventStarted value)? started,
    TResult? Function(_CallControlEventAnswered value)? answered,
    TResult? Function(_CallControlEventEnded value)? ended,
    TResult? Function(_CallControlEventSetHeld value)? setHeld,
    TResult? Function(_CallControlEventSetMuted value)? setMuted,
    TResult? Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult? Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult? Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult? Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult? Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult? Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult? Function(_CallControlEventBlindTransferred value)?
        blindTransferred,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallControlEventStarted value)? started,
    TResult Function(_CallControlEventAnswered value)? answered,
    TResult Function(_CallControlEventEnded value)? ended,
    TResult Function(_CallControlEventSetHeld value)? setHeld,
    TResult Function(_CallControlEventSetMuted value)? setMuted,
    TResult Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult Function(_CallControlEventBlindTransferred value)? blindTransferred,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc

class _$CallControlEventStartedImpl
    with DiagnosticableTreeMixin, CallControlEventStartedMixin
    implements _CallControlEventStarted {
  const _$CallControlEventStartedImpl(
      {this.line,
      this.generic,
      this.number,
      this.email,
      this.displayName,
      required this.video})
      : assert(!(generic == null && number == null && email == null),
            'one of generic, number or email parameters must be assign'),
        assert(
            (generic != null && number == null && email == null) ||
                (generic == null && number != null && email == null) ||
                (generic == null && number == null && email != null),
            'only one of generic, number or email parameters must be assign');

  @override
  final int? line;
  @override
  final String? generic;
  @override
  final String? number;
  @override
  final String? email;
  @override
  final String? displayName;
  @override
  final bool video;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallControlEvent.started(line: $line, generic: $generic, number: $number, email: $email, displayName: $displayName, video: $video)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CallControlEvent.started'))
      ..add(DiagnosticsProperty('line', line))
      ..add(DiagnosticsProperty('generic', generic))
      ..add(DiagnosticsProperty('number', number))
      ..add(DiagnosticsProperty('email', email))
      ..add(DiagnosticsProperty('displayName', displayName))
      ..add(DiagnosticsProperty('video', video));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallControlEventStartedImpl &&
            (identical(other.line, line) || other.line == line) &&
            (identical(other.generic, generic) || other.generic == generic) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.video, video) || other.video == video));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, line, generic, number, email, displayName, video);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? line, String? generic, String? number,
            String? email, String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
    required TResult Function(UuidValue uuid) cameraSwitched,
    required TResult Function(UuidValue uuid, bool enabled) cameraEnabled,
    required TResult Function(UuidValue uuid, bool enabled) speakerEnabled,
    required TResult Function(UuidValue uuid) failureApproved,
    required TResult Function(UuidValue uuid) blindTransferInitiated,
    required TResult Function(String number) blindTransferred,
  }) {
    return started(line, generic, number, email, displayName, video);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
    TResult? Function(UuidValue uuid)? cameraSwitched,
    TResult? Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult? Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult? Function(UuidValue uuid)? failureApproved,
    TResult? Function(UuidValue uuid)? blindTransferInitiated,
    TResult? Function(String number)? blindTransferred,
  }) {
    return started?.call(line, generic, number, email, displayName, video);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    TResult Function(UuidValue uuid)? cameraSwitched,
    TResult Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult Function(UuidValue uuid)? failureApproved,
    TResult Function(UuidValue uuid)? blindTransferInitiated,
    TResult Function(String number)? blindTransferred,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(line, generic, number, email, displayName, video);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallControlEventStarted value) started,
    required TResult Function(_CallControlEventAnswered value) answered,
    required TResult Function(_CallControlEventEnded value) ended,
    required TResult Function(_CallControlEventSetHeld value) setHeld,
    required TResult Function(_CallControlEventSetMuted value) setMuted,
    required TResult Function(_CallControlEventSentDTMF value) sentDTMF,
    required TResult Function(_CallControlEventCameraSwitched value)
        cameraSwitched,
    required TResult Function(_CallControlEventCameraEnabled value)
        cameraEnabled,
    required TResult Function(_CallControlEventSpeakerEnabled value)
        speakerEnabled,
    required TResult Function(_CallControlEventFailureApproved value)
        failureApproved,
    required TResult Function(_CallControlEventBlindTransferInitiated value)
        blindTransferInitiated,
    required TResult Function(_CallControlEventBlindTransferred value)
        blindTransferred,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallControlEventStarted value)? started,
    TResult? Function(_CallControlEventAnswered value)? answered,
    TResult? Function(_CallControlEventEnded value)? ended,
    TResult? Function(_CallControlEventSetHeld value)? setHeld,
    TResult? Function(_CallControlEventSetMuted value)? setMuted,
    TResult? Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult? Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult? Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult? Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult? Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult? Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult? Function(_CallControlEventBlindTransferred value)?
        blindTransferred,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallControlEventStarted value)? started,
    TResult Function(_CallControlEventAnswered value)? answered,
    TResult Function(_CallControlEventEnded value)? ended,
    TResult Function(_CallControlEventSetHeld value)? setHeld,
    TResult Function(_CallControlEventSetMuted value)? setMuted,
    TResult Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult Function(_CallControlEventBlindTransferred value)? blindTransferred,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _CallControlEventStarted
    implements CallControlEvent, CallControlEventStartedMixin {
  const factory _CallControlEventStarted(
      {final int? line,
      final String? generic,
      final String? number,
      final String? email,
      final String? displayName,
      required final bool video}) = _$CallControlEventStartedImpl;

  int? get line;
  String? get generic;
  String? get number;
  String? get email;
  String? get displayName;
  bool get video;
}

/// @nodoc

class _$CallControlEventAnsweredImpl
    with DiagnosticableTreeMixin
    implements _CallControlEventAnswered {
  const _$CallControlEventAnsweredImpl(this.uuid);

  @override
  final UuidValue uuid;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallControlEvent.answered(uuid: $uuid)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CallControlEvent.answered'))
      ..add(DiagnosticsProperty('uuid', uuid));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallControlEventAnsweredImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? line, String? generic, String? number,
            String? email, String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
    required TResult Function(UuidValue uuid) cameraSwitched,
    required TResult Function(UuidValue uuid, bool enabled) cameraEnabled,
    required TResult Function(UuidValue uuid, bool enabled) speakerEnabled,
    required TResult Function(UuidValue uuid) failureApproved,
    required TResult Function(UuidValue uuid) blindTransferInitiated,
    required TResult Function(String number) blindTransferred,
  }) {
    return answered(uuid);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
    TResult? Function(UuidValue uuid)? cameraSwitched,
    TResult? Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult? Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult? Function(UuidValue uuid)? failureApproved,
    TResult? Function(UuidValue uuid)? blindTransferInitiated,
    TResult? Function(String number)? blindTransferred,
  }) {
    return answered?.call(uuid);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    TResult Function(UuidValue uuid)? cameraSwitched,
    TResult Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult Function(UuidValue uuid)? failureApproved,
    TResult Function(UuidValue uuid)? blindTransferInitiated,
    TResult Function(String number)? blindTransferred,
    required TResult orElse(),
  }) {
    if (answered != null) {
      return answered(uuid);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallControlEventStarted value) started,
    required TResult Function(_CallControlEventAnswered value) answered,
    required TResult Function(_CallControlEventEnded value) ended,
    required TResult Function(_CallControlEventSetHeld value) setHeld,
    required TResult Function(_CallControlEventSetMuted value) setMuted,
    required TResult Function(_CallControlEventSentDTMF value) sentDTMF,
    required TResult Function(_CallControlEventCameraSwitched value)
        cameraSwitched,
    required TResult Function(_CallControlEventCameraEnabled value)
        cameraEnabled,
    required TResult Function(_CallControlEventSpeakerEnabled value)
        speakerEnabled,
    required TResult Function(_CallControlEventFailureApproved value)
        failureApproved,
    required TResult Function(_CallControlEventBlindTransferInitiated value)
        blindTransferInitiated,
    required TResult Function(_CallControlEventBlindTransferred value)
        blindTransferred,
  }) {
    return answered(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallControlEventStarted value)? started,
    TResult? Function(_CallControlEventAnswered value)? answered,
    TResult? Function(_CallControlEventEnded value)? ended,
    TResult? Function(_CallControlEventSetHeld value)? setHeld,
    TResult? Function(_CallControlEventSetMuted value)? setMuted,
    TResult? Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult? Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult? Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult? Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult? Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult? Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult? Function(_CallControlEventBlindTransferred value)?
        blindTransferred,
  }) {
    return answered?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallControlEventStarted value)? started,
    TResult Function(_CallControlEventAnswered value)? answered,
    TResult Function(_CallControlEventEnded value)? ended,
    TResult Function(_CallControlEventSetHeld value)? setHeld,
    TResult Function(_CallControlEventSetMuted value)? setMuted,
    TResult Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult Function(_CallControlEventBlindTransferred value)? blindTransferred,
    required TResult orElse(),
  }) {
    if (answered != null) {
      return answered(this);
    }
    return orElse();
  }
}

abstract class _CallControlEventAnswered implements CallControlEvent {
  const factory _CallControlEventAnswered(final UuidValue uuid) =
      _$CallControlEventAnsweredImpl;

  UuidValue get uuid;
}

/// @nodoc

class _$CallControlEventEndedImpl
    with DiagnosticableTreeMixin
    implements _CallControlEventEnded {
  const _$CallControlEventEndedImpl(this.uuid);

  @override
  final UuidValue uuid;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallControlEvent.ended(uuid: $uuid)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CallControlEvent.ended'))
      ..add(DiagnosticsProperty('uuid', uuid));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallControlEventEndedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? line, String? generic, String? number,
            String? email, String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
    required TResult Function(UuidValue uuid) cameraSwitched,
    required TResult Function(UuidValue uuid, bool enabled) cameraEnabled,
    required TResult Function(UuidValue uuid, bool enabled) speakerEnabled,
    required TResult Function(UuidValue uuid) failureApproved,
    required TResult Function(UuidValue uuid) blindTransferInitiated,
    required TResult Function(String number) blindTransferred,
  }) {
    return ended(uuid);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
    TResult? Function(UuidValue uuid)? cameraSwitched,
    TResult? Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult? Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult? Function(UuidValue uuid)? failureApproved,
    TResult? Function(UuidValue uuid)? blindTransferInitiated,
    TResult? Function(String number)? blindTransferred,
  }) {
    return ended?.call(uuid);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    TResult Function(UuidValue uuid)? cameraSwitched,
    TResult Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult Function(UuidValue uuid)? failureApproved,
    TResult Function(UuidValue uuid)? blindTransferInitiated,
    TResult Function(String number)? blindTransferred,
    required TResult orElse(),
  }) {
    if (ended != null) {
      return ended(uuid);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallControlEventStarted value) started,
    required TResult Function(_CallControlEventAnswered value) answered,
    required TResult Function(_CallControlEventEnded value) ended,
    required TResult Function(_CallControlEventSetHeld value) setHeld,
    required TResult Function(_CallControlEventSetMuted value) setMuted,
    required TResult Function(_CallControlEventSentDTMF value) sentDTMF,
    required TResult Function(_CallControlEventCameraSwitched value)
        cameraSwitched,
    required TResult Function(_CallControlEventCameraEnabled value)
        cameraEnabled,
    required TResult Function(_CallControlEventSpeakerEnabled value)
        speakerEnabled,
    required TResult Function(_CallControlEventFailureApproved value)
        failureApproved,
    required TResult Function(_CallControlEventBlindTransferInitiated value)
        blindTransferInitiated,
    required TResult Function(_CallControlEventBlindTransferred value)
        blindTransferred,
  }) {
    return ended(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallControlEventStarted value)? started,
    TResult? Function(_CallControlEventAnswered value)? answered,
    TResult? Function(_CallControlEventEnded value)? ended,
    TResult? Function(_CallControlEventSetHeld value)? setHeld,
    TResult? Function(_CallControlEventSetMuted value)? setMuted,
    TResult? Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult? Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult? Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult? Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult? Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult? Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult? Function(_CallControlEventBlindTransferred value)?
        blindTransferred,
  }) {
    return ended?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallControlEventStarted value)? started,
    TResult Function(_CallControlEventAnswered value)? answered,
    TResult Function(_CallControlEventEnded value)? ended,
    TResult Function(_CallControlEventSetHeld value)? setHeld,
    TResult Function(_CallControlEventSetMuted value)? setMuted,
    TResult Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult Function(_CallControlEventBlindTransferred value)? blindTransferred,
    required TResult orElse(),
  }) {
    if (ended != null) {
      return ended(this);
    }
    return orElse();
  }
}

abstract class _CallControlEventEnded implements CallControlEvent {
  const factory _CallControlEventEnded(final UuidValue uuid) =
      _$CallControlEventEndedImpl;

  UuidValue get uuid;
}

/// @nodoc

class _$CallControlEventSetHeldImpl
    with DiagnosticableTreeMixin
    implements _CallControlEventSetHeld {
  const _$CallControlEventSetHeldImpl(this.uuid, this.onHold);

  @override
  final UuidValue uuid;
  @override
  final bool onHold;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallControlEvent.setHeld(uuid: $uuid, onHold: $onHold)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CallControlEvent.setHeld'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('onHold', onHold));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallControlEventSetHeldImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.onHold, onHold) || other.onHold == onHold));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, onHold);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? line, String? generic, String? number,
            String? email, String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
    required TResult Function(UuidValue uuid) cameraSwitched,
    required TResult Function(UuidValue uuid, bool enabled) cameraEnabled,
    required TResult Function(UuidValue uuid, bool enabled) speakerEnabled,
    required TResult Function(UuidValue uuid) failureApproved,
    required TResult Function(UuidValue uuid) blindTransferInitiated,
    required TResult Function(String number) blindTransferred,
  }) {
    return setHeld(uuid, onHold);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
    TResult? Function(UuidValue uuid)? cameraSwitched,
    TResult? Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult? Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult? Function(UuidValue uuid)? failureApproved,
    TResult? Function(UuidValue uuid)? blindTransferInitiated,
    TResult? Function(String number)? blindTransferred,
  }) {
    return setHeld?.call(uuid, onHold);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    TResult Function(UuidValue uuid)? cameraSwitched,
    TResult Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult Function(UuidValue uuid)? failureApproved,
    TResult Function(UuidValue uuid)? blindTransferInitiated,
    TResult Function(String number)? blindTransferred,
    required TResult orElse(),
  }) {
    if (setHeld != null) {
      return setHeld(uuid, onHold);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallControlEventStarted value) started,
    required TResult Function(_CallControlEventAnswered value) answered,
    required TResult Function(_CallControlEventEnded value) ended,
    required TResult Function(_CallControlEventSetHeld value) setHeld,
    required TResult Function(_CallControlEventSetMuted value) setMuted,
    required TResult Function(_CallControlEventSentDTMF value) sentDTMF,
    required TResult Function(_CallControlEventCameraSwitched value)
        cameraSwitched,
    required TResult Function(_CallControlEventCameraEnabled value)
        cameraEnabled,
    required TResult Function(_CallControlEventSpeakerEnabled value)
        speakerEnabled,
    required TResult Function(_CallControlEventFailureApproved value)
        failureApproved,
    required TResult Function(_CallControlEventBlindTransferInitiated value)
        blindTransferInitiated,
    required TResult Function(_CallControlEventBlindTransferred value)
        blindTransferred,
  }) {
    return setHeld(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallControlEventStarted value)? started,
    TResult? Function(_CallControlEventAnswered value)? answered,
    TResult? Function(_CallControlEventEnded value)? ended,
    TResult? Function(_CallControlEventSetHeld value)? setHeld,
    TResult? Function(_CallControlEventSetMuted value)? setMuted,
    TResult? Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult? Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult? Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult? Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult? Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult? Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult? Function(_CallControlEventBlindTransferred value)?
        blindTransferred,
  }) {
    return setHeld?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallControlEventStarted value)? started,
    TResult Function(_CallControlEventAnswered value)? answered,
    TResult Function(_CallControlEventEnded value)? ended,
    TResult Function(_CallControlEventSetHeld value)? setHeld,
    TResult Function(_CallControlEventSetMuted value)? setMuted,
    TResult Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult Function(_CallControlEventBlindTransferred value)? blindTransferred,
    required TResult orElse(),
  }) {
    if (setHeld != null) {
      return setHeld(this);
    }
    return orElse();
  }
}

abstract class _CallControlEventSetHeld implements CallControlEvent {
  const factory _CallControlEventSetHeld(
      final UuidValue uuid, final bool onHold) = _$CallControlEventSetHeldImpl;

  UuidValue get uuid;
  bool get onHold;
}

/// @nodoc

class _$CallControlEventSetMutedImpl
    with DiagnosticableTreeMixin
    implements _CallControlEventSetMuted {
  const _$CallControlEventSetMutedImpl(this.uuid, this.muted);

  @override
  final UuidValue uuid;
  @override
  final bool muted;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallControlEvent.setMuted(uuid: $uuid, muted: $muted)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CallControlEvent.setMuted'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('muted', muted));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallControlEventSetMutedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.muted, muted) || other.muted == muted));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, muted);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? line, String? generic, String? number,
            String? email, String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
    required TResult Function(UuidValue uuid) cameraSwitched,
    required TResult Function(UuidValue uuid, bool enabled) cameraEnabled,
    required TResult Function(UuidValue uuid, bool enabled) speakerEnabled,
    required TResult Function(UuidValue uuid) failureApproved,
    required TResult Function(UuidValue uuid) blindTransferInitiated,
    required TResult Function(String number) blindTransferred,
  }) {
    return setMuted(uuid, muted);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
    TResult? Function(UuidValue uuid)? cameraSwitched,
    TResult? Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult? Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult? Function(UuidValue uuid)? failureApproved,
    TResult? Function(UuidValue uuid)? blindTransferInitiated,
    TResult? Function(String number)? blindTransferred,
  }) {
    return setMuted?.call(uuid, muted);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    TResult Function(UuidValue uuid)? cameraSwitched,
    TResult Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult Function(UuidValue uuid)? failureApproved,
    TResult Function(UuidValue uuid)? blindTransferInitiated,
    TResult Function(String number)? blindTransferred,
    required TResult orElse(),
  }) {
    if (setMuted != null) {
      return setMuted(uuid, muted);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallControlEventStarted value) started,
    required TResult Function(_CallControlEventAnswered value) answered,
    required TResult Function(_CallControlEventEnded value) ended,
    required TResult Function(_CallControlEventSetHeld value) setHeld,
    required TResult Function(_CallControlEventSetMuted value) setMuted,
    required TResult Function(_CallControlEventSentDTMF value) sentDTMF,
    required TResult Function(_CallControlEventCameraSwitched value)
        cameraSwitched,
    required TResult Function(_CallControlEventCameraEnabled value)
        cameraEnabled,
    required TResult Function(_CallControlEventSpeakerEnabled value)
        speakerEnabled,
    required TResult Function(_CallControlEventFailureApproved value)
        failureApproved,
    required TResult Function(_CallControlEventBlindTransferInitiated value)
        blindTransferInitiated,
    required TResult Function(_CallControlEventBlindTransferred value)
        blindTransferred,
  }) {
    return setMuted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallControlEventStarted value)? started,
    TResult? Function(_CallControlEventAnswered value)? answered,
    TResult? Function(_CallControlEventEnded value)? ended,
    TResult? Function(_CallControlEventSetHeld value)? setHeld,
    TResult? Function(_CallControlEventSetMuted value)? setMuted,
    TResult? Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult? Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult? Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult? Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult? Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult? Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult? Function(_CallControlEventBlindTransferred value)?
        blindTransferred,
  }) {
    return setMuted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallControlEventStarted value)? started,
    TResult Function(_CallControlEventAnswered value)? answered,
    TResult Function(_CallControlEventEnded value)? ended,
    TResult Function(_CallControlEventSetHeld value)? setHeld,
    TResult Function(_CallControlEventSetMuted value)? setMuted,
    TResult Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult Function(_CallControlEventBlindTransferred value)? blindTransferred,
    required TResult orElse(),
  }) {
    if (setMuted != null) {
      return setMuted(this);
    }
    return orElse();
  }
}

abstract class _CallControlEventSetMuted implements CallControlEvent {
  const factory _CallControlEventSetMuted(
      final UuidValue uuid, final bool muted) = _$CallControlEventSetMutedImpl;

  UuidValue get uuid;
  bool get muted;
}

/// @nodoc

class _$CallControlEventSentDTMFImpl
    with DiagnosticableTreeMixin
    implements _CallControlEventSentDTMF {
  const _$CallControlEventSentDTMFImpl(this.uuid, this.key);

  @override
  final UuidValue uuid;
  @override
  final String key;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallControlEvent.sentDTMF(uuid: $uuid, key: $key)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CallControlEvent.sentDTMF'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('key', key));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallControlEventSentDTMFImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, key);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? line, String? generic, String? number,
            String? email, String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
    required TResult Function(UuidValue uuid) cameraSwitched,
    required TResult Function(UuidValue uuid, bool enabled) cameraEnabled,
    required TResult Function(UuidValue uuid, bool enabled) speakerEnabled,
    required TResult Function(UuidValue uuid) failureApproved,
    required TResult Function(UuidValue uuid) blindTransferInitiated,
    required TResult Function(String number) blindTransferred,
  }) {
    return sentDTMF(uuid, key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
    TResult? Function(UuidValue uuid)? cameraSwitched,
    TResult? Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult? Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult? Function(UuidValue uuid)? failureApproved,
    TResult? Function(UuidValue uuid)? blindTransferInitiated,
    TResult? Function(String number)? blindTransferred,
  }) {
    return sentDTMF?.call(uuid, key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    TResult Function(UuidValue uuid)? cameraSwitched,
    TResult Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult Function(UuidValue uuid)? failureApproved,
    TResult Function(UuidValue uuid)? blindTransferInitiated,
    TResult Function(String number)? blindTransferred,
    required TResult orElse(),
  }) {
    if (sentDTMF != null) {
      return sentDTMF(uuid, key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallControlEventStarted value) started,
    required TResult Function(_CallControlEventAnswered value) answered,
    required TResult Function(_CallControlEventEnded value) ended,
    required TResult Function(_CallControlEventSetHeld value) setHeld,
    required TResult Function(_CallControlEventSetMuted value) setMuted,
    required TResult Function(_CallControlEventSentDTMF value) sentDTMF,
    required TResult Function(_CallControlEventCameraSwitched value)
        cameraSwitched,
    required TResult Function(_CallControlEventCameraEnabled value)
        cameraEnabled,
    required TResult Function(_CallControlEventSpeakerEnabled value)
        speakerEnabled,
    required TResult Function(_CallControlEventFailureApproved value)
        failureApproved,
    required TResult Function(_CallControlEventBlindTransferInitiated value)
        blindTransferInitiated,
    required TResult Function(_CallControlEventBlindTransferred value)
        blindTransferred,
  }) {
    return sentDTMF(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallControlEventStarted value)? started,
    TResult? Function(_CallControlEventAnswered value)? answered,
    TResult? Function(_CallControlEventEnded value)? ended,
    TResult? Function(_CallControlEventSetHeld value)? setHeld,
    TResult? Function(_CallControlEventSetMuted value)? setMuted,
    TResult? Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult? Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult? Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult? Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult? Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult? Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult? Function(_CallControlEventBlindTransferred value)?
        blindTransferred,
  }) {
    return sentDTMF?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallControlEventStarted value)? started,
    TResult Function(_CallControlEventAnswered value)? answered,
    TResult Function(_CallControlEventEnded value)? ended,
    TResult Function(_CallControlEventSetHeld value)? setHeld,
    TResult Function(_CallControlEventSetMuted value)? setMuted,
    TResult Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult Function(_CallControlEventBlindTransferred value)? blindTransferred,
    required TResult orElse(),
  }) {
    if (sentDTMF != null) {
      return sentDTMF(this);
    }
    return orElse();
  }
}

abstract class _CallControlEventSentDTMF implements CallControlEvent {
  const factory _CallControlEventSentDTMF(
      final UuidValue uuid, final String key) = _$CallControlEventSentDTMFImpl;

  UuidValue get uuid;
  String get key;
}

/// @nodoc

class _$CallControlEventCameraSwitchedImpl
    with DiagnosticableTreeMixin
    implements _CallControlEventCameraSwitched {
  const _$CallControlEventCameraSwitchedImpl(this.uuid);

  @override
  final UuidValue uuid;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallControlEvent.cameraSwitched(uuid: $uuid)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CallControlEvent.cameraSwitched'))
      ..add(DiagnosticsProperty('uuid', uuid));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallControlEventCameraSwitchedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? line, String? generic, String? number,
            String? email, String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
    required TResult Function(UuidValue uuid) cameraSwitched,
    required TResult Function(UuidValue uuid, bool enabled) cameraEnabled,
    required TResult Function(UuidValue uuid, bool enabled) speakerEnabled,
    required TResult Function(UuidValue uuid) failureApproved,
    required TResult Function(UuidValue uuid) blindTransferInitiated,
    required TResult Function(String number) blindTransferred,
  }) {
    return cameraSwitched(uuid);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
    TResult? Function(UuidValue uuid)? cameraSwitched,
    TResult? Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult? Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult? Function(UuidValue uuid)? failureApproved,
    TResult? Function(UuidValue uuid)? blindTransferInitiated,
    TResult? Function(String number)? blindTransferred,
  }) {
    return cameraSwitched?.call(uuid);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    TResult Function(UuidValue uuid)? cameraSwitched,
    TResult Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult Function(UuidValue uuid)? failureApproved,
    TResult Function(UuidValue uuid)? blindTransferInitiated,
    TResult Function(String number)? blindTransferred,
    required TResult orElse(),
  }) {
    if (cameraSwitched != null) {
      return cameraSwitched(uuid);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallControlEventStarted value) started,
    required TResult Function(_CallControlEventAnswered value) answered,
    required TResult Function(_CallControlEventEnded value) ended,
    required TResult Function(_CallControlEventSetHeld value) setHeld,
    required TResult Function(_CallControlEventSetMuted value) setMuted,
    required TResult Function(_CallControlEventSentDTMF value) sentDTMF,
    required TResult Function(_CallControlEventCameraSwitched value)
        cameraSwitched,
    required TResult Function(_CallControlEventCameraEnabled value)
        cameraEnabled,
    required TResult Function(_CallControlEventSpeakerEnabled value)
        speakerEnabled,
    required TResult Function(_CallControlEventFailureApproved value)
        failureApproved,
    required TResult Function(_CallControlEventBlindTransferInitiated value)
        blindTransferInitiated,
    required TResult Function(_CallControlEventBlindTransferred value)
        blindTransferred,
  }) {
    return cameraSwitched(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallControlEventStarted value)? started,
    TResult? Function(_CallControlEventAnswered value)? answered,
    TResult? Function(_CallControlEventEnded value)? ended,
    TResult? Function(_CallControlEventSetHeld value)? setHeld,
    TResult? Function(_CallControlEventSetMuted value)? setMuted,
    TResult? Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult? Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult? Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult? Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult? Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult? Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult? Function(_CallControlEventBlindTransferred value)?
        blindTransferred,
  }) {
    return cameraSwitched?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallControlEventStarted value)? started,
    TResult Function(_CallControlEventAnswered value)? answered,
    TResult Function(_CallControlEventEnded value)? ended,
    TResult Function(_CallControlEventSetHeld value)? setHeld,
    TResult Function(_CallControlEventSetMuted value)? setMuted,
    TResult Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult Function(_CallControlEventBlindTransferred value)? blindTransferred,
    required TResult orElse(),
  }) {
    if (cameraSwitched != null) {
      return cameraSwitched(this);
    }
    return orElse();
  }
}

abstract class _CallControlEventCameraSwitched implements CallControlEvent {
  const factory _CallControlEventCameraSwitched(final UuidValue uuid) =
      _$CallControlEventCameraSwitchedImpl;

  UuidValue get uuid;
}

/// @nodoc

class _$CallControlEventCameraEnabledImpl
    with DiagnosticableTreeMixin
    implements _CallControlEventCameraEnabled {
  const _$CallControlEventCameraEnabledImpl(this.uuid, this.enabled);

  @override
  final UuidValue uuid;
  @override
  final bool enabled;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallControlEvent.cameraEnabled(uuid: $uuid, enabled: $enabled)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CallControlEvent.cameraEnabled'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('enabled', enabled));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallControlEventCameraEnabledImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.enabled, enabled) || other.enabled == enabled));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, enabled);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? line, String? generic, String? number,
            String? email, String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
    required TResult Function(UuidValue uuid) cameraSwitched,
    required TResult Function(UuidValue uuid, bool enabled) cameraEnabled,
    required TResult Function(UuidValue uuid, bool enabled) speakerEnabled,
    required TResult Function(UuidValue uuid) failureApproved,
    required TResult Function(UuidValue uuid) blindTransferInitiated,
    required TResult Function(String number) blindTransferred,
  }) {
    return cameraEnabled(uuid, enabled);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
    TResult? Function(UuidValue uuid)? cameraSwitched,
    TResult? Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult? Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult? Function(UuidValue uuid)? failureApproved,
    TResult? Function(UuidValue uuid)? blindTransferInitiated,
    TResult? Function(String number)? blindTransferred,
  }) {
    return cameraEnabled?.call(uuid, enabled);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    TResult Function(UuidValue uuid)? cameraSwitched,
    TResult Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult Function(UuidValue uuid)? failureApproved,
    TResult Function(UuidValue uuid)? blindTransferInitiated,
    TResult Function(String number)? blindTransferred,
    required TResult orElse(),
  }) {
    if (cameraEnabled != null) {
      return cameraEnabled(uuid, enabled);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallControlEventStarted value) started,
    required TResult Function(_CallControlEventAnswered value) answered,
    required TResult Function(_CallControlEventEnded value) ended,
    required TResult Function(_CallControlEventSetHeld value) setHeld,
    required TResult Function(_CallControlEventSetMuted value) setMuted,
    required TResult Function(_CallControlEventSentDTMF value) sentDTMF,
    required TResult Function(_CallControlEventCameraSwitched value)
        cameraSwitched,
    required TResult Function(_CallControlEventCameraEnabled value)
        cameraEnabled,
    required TResult Function(_CallControlEventSpeakerEnabled value)
        speakerEnabled,
    required TResult Function(_CallControlEventFailureApproved value)
        failureApproved,
    required TResult Function(_CallControlEventBlindTransferInitiated value)
        blindTransferInitiated,
    required TResult Function(_CallControlEventBlindTransferred value)
        blindTransferred,
  }) {
    return cameraEnabled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallControlEventStarted value)? started,
    TResult? Function(_CallControlEventAnswered value)? answered,
    TResult? Function(_CallControlEventEnded value)? ended,
    TResult? Function(_CallControlEventSetHeld value)? setHeld,
    TResult? Function(_CallControlEventSetMuted value)? setMuted,
    TResult? Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult? Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult? Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult? Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult? Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult? Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult? Function(_CallControlEventBlindTransferred value)?
        blindTransferred,
  }) {
    return cameraEnabled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallControlEventStarted value)? started,
    TResult Function(_CallControlEventAnswered value)? answered,
    TResult Function(_CallControlEventEnded value)? ended,
    TResult Function(_CallControlEventSetHeld value)? setHeld,
    TResult Function(_CallControlEventSetMuted value)? setMuted,
    TResult Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult Function(_CallControlEventBlindTransferred value)? blindTransferred,
    required TResult orElse(),
  }) {
    if (cameraEnabled != null) {
      return cameraEnabled(this);
    }
    return orElse();
  }
}

abstract class _CallControlEventCameraEnabled implements CallControlEvent {
  const factory _CallControlEventCameraEnabled(
          final UuidValue uuid, final bool enabled) =
      _$CallControlEventCameraEnabledImpl;

  UuidValue get uuid;
  bool get enabled;
}

/// @nodoc

class _$CallControlEventSpeakerEnabledImpl
    with DiagnosticableTreeMixin
    implements _CallControlEventSpeakerEnabled {
  const _$CallControlEventSpeakerEnabledImpl(this.uuid, this.enabled);

  @override
  final UuidValue uuid;
  @override
  final bool enabled;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallControlEvent.speakerEnabled(uuid: $uuid, enabled: $enabled)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CallControlEvent.speakerEnabled'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('enabled', enabled));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallControlEventSpeakerEnabledImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.enabled, enabled) || other.enabled == enabled));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, enabled);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? line, String? generic, String? number,
            String? email, String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
    required TResult Function(UuidValue uuid) cameraSwitched,
    required TResult Function(UuidValue uuid, bool enabled) cameraEnabled,
    required TResult Function(UuidValue uuid, bool enabled) speakerEnabled,
    required TResult Function(UuidValue uuid) failureApproved,
    required TResult Function(UuidValue uuid) blindTransferInitiated,
    required TResult Function(String number) blindTransferred,
  }) {
    return speakerEnabled(uuid, enabled);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
    TResult? Function(UuidValue uuid)? cameraSwitched,
    TResult? Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult? Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult? Function(UuidValue uuid)? failureApproved,
    TResult? Function(UuidValue uuid)? blindTransferInitiated,
    TResult? Function(String number)? blindTransferred,
  }) {
    return speakerEnabled?.call(uuid, enabled);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    TResult Function(UuidValue uuid)? cameraSwitched,
    TResult Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult Function(UuidValue uuid)? failureApproved,
    TResult Function(UuidValue uuid)? blindTransferInitiated,
    TResult Function(String number)? blindTransferred,
    required TResult orElse(),
  }) {
    if (speakerEnabled != null) {
      return speakerEnabled(uuid, enabled);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallControlEventStarted value) started,
    required TResult Function(_CallControlEventAnswered value) answered,
    required TResult Function(_CallControlEventEnded value) ended,
    required TResult Function(_CallControlEventSetHeld value) setHeld,
    required TResult Function(_CallControlEventSetMuted value) setMuted,
    required TResult Function(_CallControlEventSentDTMF value) sentDTMF,
    required TResult Function(_CallControlEventCameraSwitched value)
        cameraSwitched,
    required TResult Function(_CallControlEventCameraEnabled value)
        cameraEnabled,
    required TResult Function(_CallControlEventSpeakerEnabled value)
        speakerEnabled,
    required TResult Function(_CallControlEventFailureApproved value)
        failureApproved,
    required TResult Function(_CallControlEventBlindTransferInitiated value)
        blindTransferInitiated,
    required TResult Function(_CallControlEventBlindTransferred value)
        blindTransferred,
  }) {
    return speakerEnabled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallControlEventStarted value)? started,
    TResult? Function(_CallControlEventAnswered value)? answered,
    TResult? Function(_CallControlEventEnded value)? ended,
    TResult? Function(_CallControlEventSetHeld value)? setHeld,
    TResult? Function(_CallControlEventSetMuted value)? setMuted,
    TResult? Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult? Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult? Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult? Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult? Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult? Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult? Function(_CallControlEventBlindTransferred value)?
        blindTransferred,
  }) {
    return speakerEnabled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallControlEventStarted value)? started,
    TResult Function(_CallControlEventAnswered value)? answered,
    TResult Function(_CallControlEventEnded value)? ended,
    TResult Function(_CallControlEventSetHeld value)? setHeld,
    TResult Function(_CallControlEventSetMuted value)? setMuted,
    TResult Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult Function(_CallControlEventBlindTransferred value)? blindTransferred,
    required TResult orElse(),
  }) {
    if (speakerEnabled != null) {
      return speakerEnabled(this);
    }
    return orElse();
  }
}

abstract class _CallControlEventSpeakerEnabled implements CallControlEvent {
  const factory _CallControlEventSpeakerEnabled(
          final UuidValue uuid, final bool enabled) =
      _$CallControlEventSpeakerEnabledImpl;

  UuidValue get uuid;
  bool get enabled;
}

/// @nodoc

class _$CallControlEventFailureApprovedImpl
    with DiagnosticableTreeMixin
    implements _CallControlEventFailureApproved {
  const _$CallControlEventFailureApprovedImpl(this.uuid);

  @override
  final UuidValue uuid;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallControlEvent.failureApproved(uuid: $uuid)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CallControlEvent.failureApproved'))
      ..add(DiagnosticsProperty('uuid', uuid));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallControlEventFailureApprovedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? line, String? generic, String? number,
            String? email, String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
    required TResult Function(UuidValue uuid) cameraSwitched,
    required TResult Function(UuidValue uuid, bool enabled) cameraEnabled,
    required TResult Function(UuidValue uuid, bool enabled) speakerEnabled,
    required TResult Function(UuidValue uuid) failureApproved,
    required TResult Function(UuidValue uuid) blindTransferInitiated,
    required TResult Function(String number) blindTransferred,
  }) {
    return failureApproved(uuid);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
    TResult? Function(UuidValue uuid)? cameraSwitched,
    TResult? Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult? Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult? Function(UuidValue uuid)? failureApproved,
    TResult? Function(UuidValue uuid)? blindTransferInitiated,
    TResult? Function(String number)? blindTransferred,
  }) {
    return failureApproved?.call(uuid);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    TResult Function(UuidValue uuid)? cameraSwitched,
    TResult Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult Function(UuidValue uuid)? failureApproved,
    TResult Function(UuidValue uuid)? blindTransferInitiated,
    TResult Function(String number)? blindTransferred,
    required TResult orElse(),
  }) {
    if (failureApproved != null) {
      return failureApproved(uuid);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallControlEventStarted value) started,
    required TResult Function(_CallControlEventAnswered value) answered,
    required TResult Function(_CallControlEventEnded value) ended,
    required TResult Function(_CallControlEventSetHeld value) setHeld,
    required TResult Function(_CallControlEventSetMuted value) setMuted,
    required TResult Function(_CallControlEventSentDTMF value) sentDTMF,
    required TResult Function(_CallControlEventCameraSwitched value)
        cameraSwitched,
    required TResult Function(_CallControlEventCameraEnabled value)
        cameraEnabled,
    required TResult Function(_CallControlEventSpeakerEnabled value)
        speakerEnabled,
    required TResult Function(_CallControlEventFailureApproved value)
        failureApproved,
    required TResult Function(_CallControlEventBlindTransferInitiated value)
        blindTransferInitiated,
    required TResult Function(_CallControlEventBlindTransferred value)
        blindTransferred,
  }) {
    return failureApproved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallControlEventStarted value)? started,
    TResult? Function(_CallControlEventAnswered value)? answered,
    TResult? Function(_CallControlEventEnded value)? ended,
    TResult? Function(_CallControlEventSetHeld value)? setHeld,
    TResult? Function(_CallControlEventSetMuted value)? setMuted,
    TResult? Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult? Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult? Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult? Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult? Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult? Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult? Function(_CallControlEventBlindTransferred value)?
        blindTransferred,
  }) {
    return failureApproved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallControlEventStarted value)? started,
    TResult Function(_CallControlEventAnswered value)? answered,
    TResult Function(_CallControlEventEnded value)? ended,
    TResult Function(_CallControlEventSetHeld value)? setHeld,
    TResult Function(_CallControlEventSetMuted value)? setMuted,
    TResult Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult Function(_CallControlEventBlindTransferred value)? blindTransferred,
    required TResult orElse(),
  }) {
    if (failureApproved != null) {
      return failureApproved(this);
    }
    return orElse();
  }
}

abstract class _CallControlEventFailureApproved implements CallControlEvent {
  const factory _CallControlEventFailureApproved(final UuidValue uuid) =
      _$CallControlEventFailureApprovedImpl;

  UuidValue get uuid;
}

/// @nodoc

class _$CallControlEventBlindTransferInitiatedImpl
    with DiagnosticableTreeMixin
    implements _CallControlEventBlindTransferInitiated {
  const _$CallControlEventBlindTransferInitiatedImpl(this.uuid);

  @override
  final UuidValue uuid;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallControlEvent.blindTransferInitiated(uuid: $uuid)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'CallControlEvent.blindTransferInitiated'))
      ..add(DiagnosticsProperty('uuid', uuid));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallControlEventBlindTransferInitiatedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? line, String? generic, String? number,
            String? email, String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
    required TResult Function(UuidValue uuid) cameraSwitched,
    required TResult Function(UuidValue uuid, bool enabled) cameraEnabled,
    required TResult Function(UuidValue uuid, bool enabled) speakerEnabled,
    required TResult Function(UuidValue uuid) failureApproved,
    required TResult Function(UuidValue uuid) blindTransferInitiated,
    required TResult Function(String number) blindTransferred,
  }) {
    return blindTransferInitiated(uuid);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
    TResult? Function(UuidValue uuid)? cameraSwitched,
    TResult? Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult? Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult? Function(UuidValue uuid)? failureApproved,
    TResult? Function(UuidValue uuid)? blindTransferInitiated,
    TResult? Function(String number)? blindTransferred,
  }) {
    return blindTransferInitiated?.call(uuid);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    TResult Function(UuidValue uuid)? cameraSwitched,
    TResult Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult Function(UuidValue uuid)? failureApproved,
    TResult Function(UuidValue uuid)? blindTransferInitiated,
    TResult Function(String number)? blindTransferred,
    required TResult orElse(),
  }) {
    if (blindTransferInitiated != null) {
      return blindTransferInitiated(uuid);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallControlEventStarted value) started,
    required TResult Function(_CallControlEventAnswered value) answered,
    required TResult Function(_CallControlEventEnded value) ended,
    required TResult Function(_CallControlEventSetHeld value) setHeld,
    required TResult Function(_CallControlEventSetMuted value) setMuted,
    required TResult Function(_CallControlEventSentDTMF value) sentDTMF,
    required TResult Function(_CallControlEventCameraSwitched value)
        cameraSwitched,
    required TResult Function(_CallControlEventCameraEnabled value)
        cameraEnabled,
    required TResult Function(_CallControlEventSpeakerEnabled value)
        speakerEnabled,
    required TResult Function(_CallControlEventFailureApproved value)
        failureApproved,
    required TResult Function(_CallControlEventBlindTransferInitiated value)
        blindTransferInitiated,
    required TResult Function(_CallControlEventBlindTransferred value)
        blindTransferred,
  }) {
    return blindTransferInitiated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallControlEventStarted value)? started,
    TResult? Function(_CallControlEventAnswered value)? answered,
    TResult? Function(_CallControlEventEnded value)? ended,
    TResult? Function(_CallControlEventSetHeld value)? setHeld,
    TResult? Function(_CallControlEventSetMuted value)? setMuted,
    TResult? Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult? Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult? Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult? Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult? Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult? Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult? Function(_CallControlEventBlindTransferred value)?
        blindTransferred,
  }) {
    return blindTransferInitiated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallControlEventStarted value)? started,
    TResult Function(_CallControlEventAnswered value)? answered,
    TResult Function(_CallControlEventEnded value)? ended,
    TResult Function(_CallControlEventSetHeld value)? setHeld,
    TResult Function(_CallControlEventSetMuted value)? setMuted,
    TResult Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult Function(_CallControlEventBlindTransferred value)? blindTransferred,
    required TResult orElse(),
  }) {
    if (blindTransferInitiated != null) {
      return blindTransferInitiated(this);
    }
    return orElse();
  }
}

abstract class _CallControlEventBlindTransferInitiated
    implements CallControlEvent {
  const factory _CallControlEventBlindTransferInitiated(final UuidValue uuid) =
      _$CallControlEventBlindTransferInitiatedImpl;

  UuidValue get uuid;
}

/// @nodoc

class _$CallControlEventBlindTransferredImpl
    with DiagnosticableTreeMixin
    implements _CallControlEventBlindTransferred {
  const _$CallControlEventBlindTransferredImpl({required this.number});

  @override
  final String number;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallControlEvent.blindTransferred(number: $number)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CallControlEvent.blindTransferred'))
      ..add(DiagnosticsProperty('number', number));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallControlEventBlindTransferredImpl &&
            (identical(other.number, number) || other.number == number));
  }

  @override
  int get hashCode => Object.hash(runtimeType, number);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? line, String? generic, String? number,
            String? email, String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
    required TResult Function(UuidValue uuid) cameraSwitched,
    required TResult Function(UuidValue uuid, bool enabled) cameraEnabled,
    required TResult Function(UuidValue uuid, bool enabled) speakerEnabled,
    required TResult Function(UuidValue uuid) failureApproved,
    required TResult Function(UuidValue uuid) blindTransferInitiated,
    required TResult Function(String number) blindTransferred,
  }) {
    return blindTransferred(number);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
    TResult? Function(UuidValue uuid)? cameraSwitched,
    TResult? Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult? Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult? Function(UuidValue uuid)? failureApproved,
    TResult? Function(UuidValue uuid)? blindTransferInitiated,
    TResult? Function(String number)? blindTransferred,
  }) {
    return blindTransferred?.call(number);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? line, String? generic, String? number, String? email,
            String? displayName, bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    TResult Function(UuidValue uuid)? cameraSwitched,
    TResult Function(UuidValue uuid, bool enabled)? cameraEnabled,
    TResult Function(UuidValue uuid, bool enabled)? speakerEnabled,
    TResult Function(UuidValue uuid)? failureApproved,
    TResult Function(UuidValue uuid)? blindTransferInitiated,
    TResult Function(String number)? blindTransferred,
    required TResult orElse(),
  }) {
    if (blindTransferred != null) {
      return blindTransferred(number);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallControlEventStarted value) started,
    required TResult Function(_CallControlEventAnswered value) answered,
    required TResult Function(_CallControlEventEnded value) ended,
    required TResult Function(_CallControlEventSetHeld value) setHeld,
    required TResult Function(_CallControlEventSetMuted value) setMuted,
    required TResult Function(_CallControlEventSentDTMF value) sentDTMF,
    required TResult Function(_CallControlEventCameraSwitched value)
        cameraSwitched,
    required TResult Function(_CallControlEventCameraEnabled value)
        cameraEnabled,
    required TResult Function(_CallControlEventSpeakerEnabled value)
        speakerEnabled,
    required TResult Function(_CallControlEventFailureApproved value)
        failureApproved,
    required TResult Function(_CallControlEventBlindTransferInitiated value)
        blindTransferInitiated,
    required TResult Function(_CallControlEventBlindTransferred value)
        blindTransferred,
  }) {
    return blindTransferred(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallControlEventStarted value)? started,
    TResult? Function(_CallControlEventAnswered value)? answered,
    TResult? Function(_CallControlEventEnded value)? ended,
    TResult? Function(_CallControlEventSetHeld value)? setHeld,
    TResult? Function(_CallControlEventSetMuted value)? setMuted,
    TResult? Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult? Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult? Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult? Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult? Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult? Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult? Function(_CallControlEventBlindTransferred value)?
        blindTransferred,
  }) {
    return blindTransferred?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallControlEventStarted value)? started,
    TResult Function(_CallControlEventAnswered value)? answered,
    TResult Function(_CallControlEventEnded value)? ended,
    TResult Function(_CallControlEventSetHeld value)? setHeld,
    TResult Function(_CallControlEventSetMuted value)? setMuted,
    TResult Function(_CallControlEventSentDTMF value)? sentDTMF,
    TResult Function(_CallControlEventCameraSwitched value)? cameraSwitched,
    TResult Function(_CallControlEventCameraEnabled value)? cameraEnabled,
    TResult Function(_CallControlEventSpeakerEnabled value)? speakerEnabled,
    TResult Function(_CallControlEventFailureApproved value)? failureApproved,
    TResult Function(_CallControlEventBlindTransferInitiated value)?
        blindTransferInitiated,
    TResult Function(_CallControlEventBlindTransferred value)? blindTransferred,
    required TResult orElse(),
  }) {
    if (blindTransferred != null) {
      return blindTransferred(this);
    }
    return orElse();
  }
}

abstract class _CallControlEventBlindTransferred implements CallControlEvent {
  const factory _CallControlEventBlindTransferred(
      {required final String number}) = _$CallControlEventBlindTransferredImpl;

  String get number;
}

/// @nodoc
mixin _$CallPerformEvent {
  UuidValue get uuid => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, CallkeepHandle handle, String? displayName,
            bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallPerformEventStarted value) started,
    required TResult Function(_CallPerformEventAnswered value) answered,
    required TResult Function(_CallPerformEventEnded value) ended,
    required TResult Function(_CallPerformEventSetHeld value) setHeld,
    required TResult Function(_CallPerformEventSetMuted value) setMuted,
    required TResult Function(_CallPerformEventSentDTMF value) sentDTMF,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallPerformEventStarted value)? started,
    TResult? Function(_CallPerformEventAnswered value)? answered,
    TResult? Function(_CallPerformEventEnded value)? ended,
    TResult? Function(_CallPerformEventSetHeld value)? setHeld,
    TResult? Function(_CallPerformEventSetMuted value)? setMuted,
    TResult? Function(_CallPerformEventSentDTMF value)? sentDTMF,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallPerformEventStarted value)? started,
    TResult Function(_CallPerformEventAnswered value)? answered,
    TResult Function(_CallPerformEventEnded value)? ended,
    TResult Function(_CallPerformEventSetHeld value)? setHeld,
    TResult Function(_CallPerformEventSetMuted value)? setMuted,
    TResult Function(_CallPerformEventSentDTMF value)? sentDTMF,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc

class _$CallPerformEventStartedImpl extends _CallPerformEventStarted
    with DiagnosticableTreeMixin {
  _$CallPerformEventStartedImpl(this.uuid,
      {required this.handle, this.displayName, required this.video})
      : super._();

  @override
  final UuidValue uuid;
  @override
  final CallkeepHandle handle;
  @override
  final String? displayName;
  @override
  final bool video;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallPerformEvent.started(uuid: $uuid, handle: $handle, displayName: $displayName, video: $video)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallPerformEvent.started'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('handle', handle))
      ..add(DiagnosticsProperty('displayName', displayName))
      ..add(DiagnosticsProperty('video', video));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallPerformEventStartedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.handle, handle) || other.handle == handle) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.video, video) || other.video == video));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, uuid, handle, displayName, video);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
  }) {
    return started(uuid, handle, displayName, video);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
  }) {
    return started?.call(uuid, handle, displayName, video);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, CallkeepHandle handle, String? displayName,
            bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(uuid, handle, displayName, video);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallPerformEventStarted value) started,
    required TResult Function(_CallPerformEventAnswered value) answered,
    required TResult Function(_CallPerformEventEnded value) ended,
    required TResult Function(_CallPerformEventSetHeld value) setHeld,
    required TResult Function(_CallPerformEventSetMuted value) setMuted,
    required TResult Function(_CallPerformEventSentDTMF value) sentDTMF,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallPerformEventStarted value)? started,
    TResult? Function(_CallPerformEventAnswered value)? answered,
    TResult? Function(_CallPerformEventEnded value)? ended,
    TResult? Function(_CallPerformEventSetHeld value)? setHeld,
    TResult? Function(_CallPerformEventSetMuted value)? setMuted,
    TResult? Function(_CallPerformEventSentDTMF value)? sentDTMF,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallPerformEventStarted value)? started,
    TResult Function(_CallPerformEventAnswered value)? answered,
    TResult Function(_CallPerformEventEnded value)? ended,
    TResult Function(_CallPerformEventSetHeld value)? setHeld,
    TResult Function(_CallPerformEventSetMuted value)? setMuted,
    TResult Function(_CallPerformEventSentDTMF value)? sentDTMF,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _CallPerformEventStarted extends _CallPerformEvent {
  factory _CallPerformEventStarted(final UuidValue uuid,
      {required final CallkeepHandle handle,
      final String? displayName,
      required final bool video}) = _$CallPerformEventStartedImpl;
  _CallPerformEventStarted._() : super._();

  @override
  UuidValue get uuid;
  CallkeepHandle get handle;
  String? get displayName;
  bool get video;
}

/// @nodoc

class _$CallPerformEventAnsweredImpl extends _CallPerformEventAnswered
    with DiagnosticableTreeMixin {
  _$CallPerformEventAnsweredImpl(this.uuid) : super._();

  @override
  final UuidValue uuid;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallPerformEvent.answered(uuid: $uuid)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallPerformEvent.answered'))
      ..add(DiagnosticsProperty('uuid', uuid));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallPerformEventAnsweredImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
  }) {
    return answered(uuid);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
  }) {
    return answered?.call(uuid);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, CallkeepHandle handle, String? displayName,
            bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    required TResult orElse(),
  }) {
    if (answered != null) {
      return answered(uuid);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallPerformEventStarted value) started,
    required TResult Function(_CallPerformEventAnswered value) answered,
    required TResult Function(_CallPerformEventEnded value) ended,
    required TResult Function(_CallPerformEventSetHeld value) setHeld,
    required TResult Function(_CallPerformEventSetMuted value) setMuted,
    required TResult Function(_CallPerformEventSentDTMF value) sentDTMF,
  }) {
    return answered(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallPerformEventStarted value)? started,
    TResult? Function(_CallPerformEventAnswered value)? answered,
    TResult? Function(_CallPerformEventEnded value)? ended,
    TResult? Function(_CallPerformEventSetHeld value)? setHeld,
    TResult? Function(_CallPerformEventSetMuted value)? setMuted,
    TResult? Function(_CallPerformEventSentDTMF value)? sentDTMF,
  }) {
    return answered?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallPerformEventStarted value)? started,
    TResult Function(_CallPerformEventAnswered value)? answered,
    TResult Function(_CallPerformEventEnded value)? ended,
    TResult Function(_CallPerformEventSetHeld value)? setHeld,
    TResult Function(_CallPerformEventSetMuted value)? setMuted,
    TResult Function(_CallPerformEventSentDTMF value)? sentDTMF,
    required TResult orElse(),
  }) {
    if (answered != null) {
      return answered(this);
    }
    return orElse();
  }
}

abstract class _CallPerformEventAnswered extends _CallPerformEvent {
  factory _CallPerformEventAnswered(final UuidValue uuid) =
      _$CallPerformEventAnsweredImpl;
  _CallPerformEventAnswered._() : super._();

  @override
  UuidValue get uuid;
}

/// @nodoc

class _$CallPerformEventEndedImpl extends _CallPerformEventEnded
    with DiagnosticableTreeMixin {
  _$CallPerformEventEndedImpl(this.uuid) : super._();

  @override
  final UuidValue uuid;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallPerformEvent.ended(uuid: $uuid)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallPerformEvent.ended'))
      ..add(DiagnosticsProperty('uuid', uuid));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallPerformEventEndedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
  }) {
    return ended(uuid);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
  }) {
    return ended?.call(uuid);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, CallkeepHandle handle, String? displayName,
            bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    required TResult orElse(),
  }) {
    if (ended != null) {
      return ended(uuid);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallPerformEventStarted value) started,
    required TResult Function(_CallPerformEventAnswered value) answered,
    required TResult Function(_CallPerformEventEnded value) ended,
    required TResult Function(_CallPerformEventSetHeld value) setHeld,
    required TResult Function(_CallPerformEventSetMuted value) setMuted,
    required TResult Function(_CallPerformEventSentDTMF value) sentDTMF,
  }) {
    return ended(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallPerformEventStarted value)? started,
    TResult? Function(_CallPerformEventAnswered value)? answered,
    TResult? Function(_CallPerformEventEnded value)? ended,
    TResult? Function(_CallPerformEventSetHeld value)? setHeld,
    TResult? Function(_CallPerformEventSetMuted value)? setMuted,
    TResult? Function(_CallPerformEventSentDTMF value)? sentDTMF,
  }) {
    return ended?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallPerformEventStarted value)? started,
    TResult Function(_CallPerformEventAnswered value)? answered,
    TResult Function(_CallPerformEventEnded value)? ended,
    TResult Function(_CallPerformEventSetHeld value)? setHeld,
    TResult Function(_CallPerformEventSetMuted value)? setMuted,
    TResult Function(_CallPerformEventSentDTMF value)? sentDTMF,
    required TResult orElse(),
  }) {
    if (ended != null) {
      return ended(this);
    }
    return orElse();
  }
}

abstract class _CallPerformEventEnded extends _CallPerformEvent {
  factory _CallPerformEventEnded(final UuidValue uuid) =
      _$CallPerformEventEndedImpl;
  _CallPerformEventEnded._() : super._();

  @override
  UuidValue get uuid;
}

/// @nodoc

class _$CallPerformEventSetHeldImpl extends _CallPerformEventSetHeld
    with DiagnosticableTreeMixin {
  _$CallPerformEventSetHeldImpl(this.uuid, this.onHold) : super._();

  @override
  final UuidValue uuid;
  @override
  final bool onHold;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallPerformEvent.setHeld(uuid: $uuid, onHold: $onHold)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallPerformEvent.setHeld'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('onHold', onHold));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallPerformEventSetHeldImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.onHold, onHold) || other.onHold == onHold));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, onHold);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
  }) {
    return setHeld(uuid, onHold);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
  }) {
    return setHeld?.call(uuid, onHold);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, CallkeepHandle handle, String? displayName,
            bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    required TResult orElse(),
  }) {
    if (setHeld != null) {
      return setHeld(uuid, onHold);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallPerformEventStarted value) started,
    required TResult Function(_CallPerformEventAnswered value) answered,
    required TResult Function(_CallPerformEventEnded value) ended,
    required TResult Function(_CallPerformEventSetHeld value) setHeld,
    required TResult Function(_CallPerformEventSetMuted value) setMuted,
    required TResult Function(_CallPerformEventSentDTMF value) sentDTMF,
  }) {
    return setHeld(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallPerformEventStarted value)? started,
    TResult? Function(_CallPerformEventAnswered value)? answered,
    TResult? Function(_CallPerformEventEnded value)? ended,
    TResult? Function(_CallPerformEventSetHeld value)? setHeld,
    TResult? Function(_CallPerformEventSetMuted value)? setMuted,
    TResult? Function(_CallPerformEventSentDTMF value)? sentDTMF,
  }) {
    return setHeld?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallPerformEventStarted value)? started,
    TResult Function(_CallPerformEventAnswered value)? answered,
    TResult Function(_CallPerformEventEnded value)? ended,
    TResult Function(_CallPerformEventSetHeld value)? setHeld,
    TResult Function(_CallPerformEventSetMuted value)? setMuted,
    TResult Function(_CallPerformEventSentDTMF value)? sentDTMF,
    required TResult orElse(),
  }) {
    if (setHeld != null) {
      return setHeld(this);
    }
    return orElse();
  }
}

abstract class _CallPerformEventSetHeld extends _CallPerformEvent {
  factory _CallPerformEventSetHeld(final UuidValue uuid, final bool onHold) =
      _$CallPerformEventSetHeldImpl;
  _CallPerformEventSetHeld._() : super._();

  @override
  UuidValue get uuid;
  bool get onHold;
}

/// @nodoc

class _$CallPerformEventSetMutedImpl extends _CallPerformEventSetMuted
    with DiagnosticableTreeMixin {
  _$CallPerformEventSetMutedImpl(this.uuid, this.muted) : super._();

  @override
  final UuidValue uuid;
  @override
  final bool muted;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallPerformEvent.setMuted(uuid: $uuid, muted: $muted)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallPerformEvent.setMuted'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('muted', muted));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallPerformEventSetMutedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.muted, muted) || other.muted == muted));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, muted);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
  }) {
    return setMuted(uuid, muted);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
  }) {
    return setMuted?.call(uuid, muted);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, CallkeepHandle handle, String? displayName,
            bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    required TResult orElse(),
  }) {
    if (setMuted != null) {
      return setMuted(uuid, muted);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallPerformEventStarted value) started,
    required TResult Function(_CallPerformEventAnswered value) answered,
    required TResult Function(_CallPerformEventEnded value) ended,
    required TResult Function(_CallPerformEventSetHeld value) setHeld,
    required TResult Function(_CallPerformEventSetMuted value) setMuted,
    required TResult Function(_CallPerformEventSentDTMF value) sentDTMF,
  }) {
    return setMuted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallPerformEventStarted value)? started,
    TResult? Function(_CallPerformEventAnswered value)? answered,
    TResult? Function(_CallPerformEventEnded value)? ended,
    TResult? Function(_CallPerformEventSetHeld value)? setHeld,
    TResult? Function(_CallPerformEventSetMuted value)? setMuted,
    TResult? Function(_CallPerformEventSentDTMF value)? sentDTMF,
  }) {
    return setMuted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallPerformEventStarted value)? started,
    TResult Function(_CallPerformEventAnswered value)? answered,
    TResult Function(_CallPerformEventEnded value)? ended,
    TResult Function(_CallPerformEventSetHeld value)? setHeld,
    TResult Function(_CallPerformEventSetMuted value)? setMuted,
    TResult Function(_CallPerformEventSentDTMF value)? sentDTMF,
    required TResult orElse(),
  }) {
    if (setMuted != null) {
      return setMuted(this);
    }
    return orElse();
  }
}

abstract class _CallPerformEventSetMuted extends _CallPerformEvent {
  factory _CallPerformEventSetMuted(final UuidValue uuid, final bool muted) =
      _$CallPerformEventSetMutedImpl;
  _CallPerformEventSetMuted._() : super._();

  @override
  UuidValue get uuid;
  bool get muted;
}

/// @nodoc

class _$CallPerformEventSentDTMFImpl extends _CallPerformEventSentDTMF
    with DiagnosticableTreeMixin {
  _$CallPerformEventSentDTMFImpl(this.uuid, this.key) : super._();

  @override
  final UuidValue uuid;
  @override
  final String key;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_CallPerformEvent.sentDTMF(uuid: $uuid, key: $key)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_CallPerformEvent.sentDTMF'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('key', key));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallPerformEventSentDTMFImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, key);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)
        started,
    required TResult Function(UuidValue uuid) answered,
    required TResult Function(UuidValue uuid) ended,
    required TResult Function(UuidValue uuid, bool onHold) setHeld,
    required TResult Function(UuidValue uuid, bool muted) setMuted,
    required TResult Function(UuidValue uuid, String key) sentDTMF,
  }) {
    return sentDTMF(uuid, key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, CallkeepHandle handle,
            String? displayName, bool video)?
        started,
    TResult? Function(UuidValue uuid)? answered,
    TResult? Function(UuidValue uuid)? ended,
    TResult? Function(UuidValue uuid, bool onHold)? setHeld,
    TResult? Function(UuidValue uuid, bool muted)? setMuted,
    TResult? Function(UuidValue uuid, String key)? sentDTMF,
  }) {
    return sentDTMF?.call(uuid, key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, CallkeepHandle handle, String? displayName,
            bool video)?
        started,
    TResult Function(UuidValue uuid)? answered,
    TResult Function(UuidValue uuid)? ended,
    TResult Function(UuidValue uuid, bool onHold)? setHeld,
    TResult Function(UuidValue uuid, bool muted)? setMuted,
    TResult Function(UuidValue uuid, String key)? sentDTMF,
    required TResult orElse(),
  }) {
    if (sentDTMF != null) {
      return sentDTMF(uuid, key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallPerformEventStarted value) started,
    required TResult Function(_CallPerformEventAnswered value) answered,
    required TResult Function(_CallPerformEventEnded value) ended,
    required TResult Function(_CallPerformEventSetHeld value) setHeld,
    required TResult Function(_CallPerformEventSetMuted value) setMuted,
    required TResult Function(_CallPerformEventSentDTMF value) sentDTMF,
  }) {
    return sentDTMF(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallPerformEventStarted value)? started,
    TResult? Function(_CallPerformEventAnswered value)? answered,
    TResult? Function(_CallPerformEventEnded value)? ended,
    TResult? Function(_CallPerformEventSetHeld value)? setHeld,
    TResult? Function(_CallPerformEventSetMuted value)? setMuted,
    TResult? Function(_CallPerformEventSentDTMF value)? sentDTMF,
  }) {
    return sentDTMF?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallPerformEventStarted value)? started,
    TResult Function(_CallPerformEventAnswered value)? answered,
    TResult Function(_CallPerformEventEnded value)? ended,
    TResult Function(_CallPerformEventSetHeld value)? setHeld,
    TResult Function(_CallPerformEventSetMuted value)? setMuted,
    TResult Function(_CallPerformEventSentDTMF value)? sentDTMF,
    required TResult orElse(),
  }) {
    if (sentDTMF != null) {
      return sentDTMF(this);
    }
    return orElse();
  }
}

abstract class _CallPerformEventSentDTMF extends _CallPerformEvent {
  factory _CallPerformEventSentDTMF(final UuidValue uuid, final String key) =
      _$CallPerformEventSentDTMFImpl;
  _CallPerformEventSentDTMF._() : super._();

  @override
  UuidValue get uuid;
  String get key;
}

/// @nodoc
mixin _$PeerConnectionEvent {
  UuidValue get uuid => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, RTCSignalingState state)
        signalingStateChanged,
    required TResult Function(UuidValue uuid, RTCPeerConnectionState state)
        connectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceGatheringState state)
        iceGatheringStateChanged,
    required TResult Function(UuidValue uuid, RTCIceConnectionState state)
        iceConnectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceCandidate candidate)
        iceCandidateIdentified,
    required TResult Function(UuidValue uuid, MediaStream stream) streamAdded,
    required TResult Function(UuidValue uuid, MediaStream stream) streamRemoved,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult? Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult? Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamRemoved,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult Function(UuidValue uuid, MediaStream stream)? streamRemoved,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PeerConnectionEventSignalingStateChanged value)
        signalingStateChanged,
    required TResult Function(_PeerConnectionEventConnectionStateChanged value)
        connectionStateChanged,
    required TResult Function(
            _PeerConnectionEventIceGatheringStateChanged value)
        iceGatheringStateChanged,
    required TResult Function(
            _PeerConnectionEventIceConnectionStateChanged value)
        iceConnectionStateChanged,
    required TResult Function(_PeerConnectionEventIceCandidateIdentified value)
        iceCandidateIdentified,
    required TResult Function(_PeerConnectionEventStreamAdded value)
        streamAdded,
    required TResult Function(_PeerConnectionEventStreamRemoved value)
        streamRemoved,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult? Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult? Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult? Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult? Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult? Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult? Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc

class _$PeerConnectionEventSignalingStateChangedImpl
    with DiagnosticableTreeMixin
    implements _PeerConnectionEventSignalingStateChanged {
  const _$PeerConnectionEventSignalingStateChangedImpl(this.uuid, this.state);

  @override
  final UuidValue uuid;
  @override
  final RTCSignalingState state;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_PeerConnectionEvent.signalingStateChanged(uuid: $uuid, state: $state)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', '_PeerConnectionEvent.signalingStateChanged'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('state', state));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PeerConnectionEventSignalingStateChangedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.state, state) || other.state == state));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, state);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, RTCSignalingState state)
        signalingStateChanged,
    required TResult Function(UuidValue uuid, RTCPeerConnectionState state)
        connectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceGatheringState state)
        iceGatheringStateChanged,
    required TResult Function(UuidValue uuid, RTCIceConnectionState state)
        iceConnectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceCandidate candidate)
        iceCandidateIdentified,
    required TResult Function(UuidValue uuid, MediaStream stream) streamAdded,
    required TResult Function(UuidValue uuid, MediaStream stream) streamRemoved,
  }) {
    return signalingStateChanged(uuid, state);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult? Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult? Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamRemoved,
  }) {
    return signalingStateChanged?.call(uuid, state);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult Function(UuidValue uuid, MediaStream stream)? streamRemoved,
    required TResult orElse(),
  }) {
    if (signalingStateChanged != null) {
      return signalingStateChanged(uuid, state);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PeerConnectionEventSignalingStateChanged value)
        signalingStateChanged,
    required TResult Function(_PeerConnectionEventConnectionStateChanged value)
        connectionStateChanged,
    required TResult Function(
            _PeerConnectionEventIceGatheringStateChanged value)
        iceGatheringStateChanged,
    required TResult Function(
            _PeerConnectionEventIceConnectionStateChanged value)
        iceConnectionStateChanged,
    required TResult Function(_PeerConnectionEventIceCandidateIdentified value)
        iceCandidateIdentified,
    required TResult Function(_PeerConnectionEventStreamAdded value)
        streamAdded,
    required TResult Function(_PeerConnectionEventStreamRemoved value)
        streamRemoved,
  }) {
    return signalingStateChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult? Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult? Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult? Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult? Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult? Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult? Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
  }) {
    return signalingStateChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
    required TResult orElse(),
  }) {
    if (signalingStateChanged != null) {
      return signalingStateChanged(this);
    }
    return orElse();
  }
}

abstract class _PeerConnectionEventSignalingStateChanged
    implements _PeerConnectionEvent {
  const factory _PeerConnectionEventSignalingStateChanged(
          final UuidValue uuid, final RTCSignalingState state) =
      _$PeerConnectionEventSignalingStateChangedImpl;

  @override
  UuidValue get uuid;
  RTCSignalingState get state;
}

/// @nodoc

class _$PeerConnectionEventConnectionStateChangedImpl
    with DiagnosticableTreeMixin
    implements _PeerConnectionEventConnectionStateChanged {
  const _$PeerConnectionEventConnectionStateChangedImpl(this.uuid, this.state);

  @override
  final UuidValue uuid;
  @override
  final RTCPeerConnectionState state;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_PeerConnectionEvent.connectionStateChanged(uuid: $uuid, state: $state)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', '_PeerConnectionEvent.connectionStateChanged'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('state', state));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PeerConnectionEventConnectionStateChangedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.state, state) || other.state == state));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, state);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, RTCSignalingState state)
        signalingStateChanged,
    required TResult Function(UuidValue uuid, RTCPeerConnectionState state)
        connectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceGatheringState state)
        iceGatheringStateChanged,
    required TResult Function(UuidValue uuid, RTCIceConnectionState state)
        iceConnectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceCandidate candidate)
        iceCandidateIdentified,
    required TResult Function(UuidValue uuid, MediaStream stream) streamAdded,
    required TResult Function(UuidValue uuid, MediaStream stream) streamRemoved,
  }) {
    return connectionStateChanged(uuid, state);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult? Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult? Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamRemoved,
  }) {
    return connectionStateChanged?.call(uuid, state);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult Function(UuidValue uuid, MediaStream stream)? streamRemoved,
    required TResult orElse(),
  }) {
    if (connectionStateChanged != null) {
      return connectionStateChanged(uuid, state);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PeerConnectionEventSignalingStateChanged value)
        signalingStateChanged,
    required TResult Function(_PeerConnectionEventConnectionStateChanged value)
        connectionStateChanged,
    required TResult Function(
            _PeerConnectionEventIceGatheringStateChanged value)
        iceGatheringStateChanged,
    required TResult Function(
            _PeerConnectionEventIceConnectionStateChanged value)
        iceConnectionStateChanged,
    required TResult Function(_PeerConnectionEventIceCandidateIdentified value)
        iceCandidateIdentified,
    required TResult Function(_PeerConnectionEventStreamAdded value)
        streamAdded,
    required TResult Function(_PeerConnectionEventStreamRemoved value)
        streamRemoved,
  }) {
    return connectionStateChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult? Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult? Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult? Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult? Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult? Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult? Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
  }) {
    return connectionStateChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
    required TResult orElse(),
  }) {
    if (connectionStateChanged != null) {
      return connectionStateChanged(this);
    }
    return orElse();
  }
}

abstract class _PeerConnectionEventConnectionStateChanged
    implements _PeerConnectionEvent {
  const factory _PeerConnectionEventConnectionStateChanged(
          final UuidValue uuid, final RTCPeerConnectionState state) =
      _$PeerConnectionEventConnectionStateChangedImpl;

  @override
  UuidValue get uuid;
  RTCPeerConnectionState get state;
}

/// @nodoc

class _$PeerConnectionEventIceGatheringStateChangedImpl
    with DiagnosticableTreeMixin
    implements _PeerConnectionEventIceGatheringStateChanged {
  const _$PeerConnectionEventIceGatheringStateChangedImpl(
      this.uuid, this.state);

  @override
  final UuidValue uuid;
  @override
  final RTCIceGatheringState state;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_PeerConnectionEvent.iceGatheringStateChanged(uuid: $uuid, state: $state)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', '_PeerConnectionEvent.iceGatheringStateChanged'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('state', state));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PeerConnectionEventIceGatheringStateChangedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.state, state) || other.state == state));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, state);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, RTCSignalingState state)
        signalingStateChanged,
    required TResult Function(UuidValue uuid, RTCPeerConnectionState state)
        connectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceGatheringState state)
        iceGatheringStateChanged,
    required TResult Function(UuidValue uuid, RTCIceConnectionState state)
        iceConnectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceCandidate candidate)
        iceCandidateIdentified,
    required TResult Function(UuidValue uuid, MediaStream stream) streamAdded,
    required TResult Function(UuidValue uuid, MediaStream stream) streamRemoved,
  }) {
    return iceGatheringStateChanged(uuid, state);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult? Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult? Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamRemoved,
  }) {
    return iceGatheringStateChanged?.call(uuid, state);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult Function(UuidValue uuid, MediaStream stream)? streamRemoved,
    required TResult orElse(),
  }) {
    if (iceGatheringStateChanged != null) {
      return iceGatheringStateChanged(uuid, state);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PeerConnectionEventSignalingStateChanged value)
        signalingStateChanged,
    required TResult Function(_PeerConnectionEventConnectionStateChanged value)
        connectionStateChanged,
    required TResult Function(
            _PeerConnectionEventIceGatheringStateChanged value)
        iceGatheringStateChanged,
    required TResult Function(
            _PeerConnectionEventIceConnectionStateChanged value)
        iceConnectionStateChanged,
    required TResult Function(_PeerConnectionEventIceCandidateIdentified value)
        iceCandidateIdentified,
    required TResult Function(_PeerConnectionEventStreamAdded value)
        streamAdded,
    required TResult Function(_PeerConnectionEventStreamRemoved value)
        streamRemoved,
  }) {
    return iceGatheringStateChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult? Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult? Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult? Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult? Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult? Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult? Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
  }) {
    return iceGatheringStateChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
    required TResult orElse(),
  }) {
    if (iceGatheringStateChanged != null) {
      return iceGatheringStateChanged(this);
    }
    return orElse();
  }
}

abstract class _PeerConnectionEventIceGatheringStateChanged
    implements _PeerConnectionEvent {
  const factory _PeerConnectionEventIceGatheringStateChanged(
          final UuidValue uuid, final RTCIceGatheringState state) =
      _$PeerConnectionEventIceGatheringStateChangedImpl;

  @override
  UuidValue get uuid;
  RTCIceGatheringState get state;
}

/// @nodoc

class _$PeerConnectionEventIceConnectionStateChangedImpl
    with DiagnosticableTreeMixin
    implements _PeerConnectionEventIceConnectionStateChanged {
  const _$PeerConnectionEventIceConnectionStateChangedImpl(
      this.uuid, this.state);

  @override
  final UuidValue uuid;
  @override
  final RTCIceConnectionState state;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_PeerConnectionEvent.iceConnectionStateChanged(uuid: $uuid, state: $state)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', '_PeerConnectionEvent.iceConnectionStateChanged'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('state', state));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PeerConnectionEventIceConnectionStateChangedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.state, state) || other.state == state));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, state);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, RTCSignalingState state)
        signalingStateChanged,
    required TResult Function(UuidValue uuid, RTCPeerConnectionState state)
        connectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceGatheringState state)
        iceGatheringStateChanged,
    required TResult Function(UuidValue uuid, RTCIceConnectionState state)
        iceConnectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceCandidate candidate)
        iceCandidateIdentified,
    required TResult Function(UuidValue uuid, MediaStream stream) streamAdded,
    required TResult Function(UuidValue uuid, MediaStream stream) streamRemoved,
  }) {
    return iceConnectionStateChanged(uuid, state);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult? Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult? Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamRemoved,
  }) {
    return iceConnectionStateChanged?.call(uuid, state);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult Function(UuidValue uuid, MediaStream stream)? streamRemoved,
    required TResult orElse(),
  }) {
    if (iceConnectionStateChanged != null) {
      return iceConnectionStateChanged(uuid, state);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PeerConnectionEventSignalingStateChanged value)
        signalingStateChanged,
    required TResult Function(_PeerConnectionEventConnectionStateChanged value)
        connectionStateChanged,
    required TResult Function(
            _PeerConnectionEventIceGatheringStateChanged value)
        iceGatheringStateChanged,
    required TResult Function(
            _PeerConnectionEventIceConnectionStateChanged value)
        iceConnectionStateChanged,
    required TResult Function(_PeerConnectionEventIceCandidateIdentified value)
        iceCandidateIdentified,
    required TResult Function(_PeerConnectionEventStreamAdded value)
        streamAdded,
    required TResult Function(_PeerConnectionEventStreamRemoved value)
        streamRemoved,
  }) {
    return iceConnectionStateChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult? Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult? Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult? Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult? Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult? Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult? Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
  }) {
    return iceConnectionStateChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
    required TResult orElse(),
  }) {
    if (iceConnectionStateChanged != null) {
      return iceConnectionStateChanged(this);
    }
    return orElse();
  }
}

abstract class _PeerConnectionEventIceConnectionStateChanged
    implements _PeerConnectionEvent {
  const factory _PeerConnectionEventIceConnectionStateChanged(
          final UuidValue uuid, final RTCIceConnectionState state) =
      _$PeerConnectionEventIceConnectionStateChangedImpl;

  @override
  UuidValue get uuid;
  RTCIceConnectionState get state;
}

/// @nodoc

class _$PeerConnectionEventIceCandidateIdentifiedImpl
    with DiagnosticableTreeMixin
    implements _PeerConnectionEventIceCandidateIdentified {
  const _$PeerConnectionEventIceCandidateIdentifiedImpl(
      this.uuid, this.candidate);

  @override
  final UuidValue uuid;
  @override
  final RTCIceCandidate candidate;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_PeerConnectionEvent.iceCandidateIdentified(uuid: $uuid, candidate: $candidate)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', '_PeerConnectionEvent.iceCandidateIdentified'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('candidate', candidate));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PeerConnectionEventIceCandidateIdentifiedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.candidate, candidate) ||
                other.candidate == candidate));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, candidate);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, RTCSignalingState state)
        signalingStateChanged,
    required TResult Function(UuidValue uuid, RTCPeerConnectionState state)
        connectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceGatheringState state)
        iceGatheringStateChanged,
    required TResult Function(UuidValue uuid, RTCIceConnectionState state)
        iceConnectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceCandidate candidate)
        iceCandidateIdentified,
    required TResult Function(UuidValue uuid, MediaStream stream) streamAdded,
    required TResult Function(UuidValue uuid, MediaStream stream) streamRemoved,
  }) {
    return iceCandidateIdentified(uuid, candidate);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult? Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult? Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamRemoved,
  }) {
    return iceCandidateIdentified?.call(uuid, candidate);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult Function(UuidValue uuid, MediaStream stream)? streamRemoved,
    required TResult orElse(),
  }) {
    if (iceCandidateIdentified != null) {
      return iceCandidateIdentified(uuid, candidate);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PeerConnectionEventSignalingStateChanged value)
        signalingStateChanged,
    required TResult Function(_PeerConnectionEventConnectionStateChanged value)
        connectionStateChanged,
    required TResult Function(
            _PeerConnectionEventIceGatheringStateChanged value)
        iceGatheringStateChanged,
    required TResult Function(
            _PeerConnectionEventIceConnectionStateChanged value)
        iceConnectionStateChanged,
    required TResult Function(_PeerConnectionEventIceCandidateIdentified value)
        iceCandidateIdentified,
    required TResult Function(_PeerConnectionEventStreamAdded value)
        streamAdded,
    required TResult Function(_PeerConnectionEventStreamRemoved value)
        streamRemoved,
  }) {
    return iceCandidateIdentified(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult? Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult? Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult? Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult? Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult? Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult? Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
  }) {
    return iceCandidateIdentified?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
    required TResult orElse(),
  }) {
    if (iceCandidateIdentified != null) {
      return iceCandidateIdentified(this);
    }
    return orElse();
  }
}

abstract class _PeerConnectionEventIceCandidateIdentified
    implements _PeerConnectionEvent {
  const factory _PeerConnectionEventIceCandidateIdentified(
          final UuidValue uuid, final RTCIceCandidate candidate) =
      _$PeerConnectionEventIceCandidateIdentifiedImpl;

  @override
  UuidValue get uuid;
  RTCIceCandidate get candidate;
}

/// @nodoc

class _$PeerConnectionEventStreamAddedImpl
    with DiagnosticableTreeMixin
    implements _PeerConnectionEventStreamAdded {
  const _$PeerConnectionEventStreamAddedImpl(this.uuid, this.stream);

  @override
  final UuidValue uuid;
  @override
  final MediaStream stream;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_PeerConnectionEvent.streamAdded(uuid: $uuid, stream: $stream)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_PeerConnectionEvent.streamAdded'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('stream', stream));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PeerConnectionEventStreamAddedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.stream, stream) || other.stream == stream));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, stream);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, RTCSignalingState state)
        signalingStateChanged,
    required TResult Function(UuidValue uuid, RTCPeerConnectionState state)
        connectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceGatheringState state)
        iceGatheringStateChanged,
    required TResult Function(UuidValue uuid, RTCIceConnectionState state)
        iceConnectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceCandidate candidate)
        iceCandidateIdentified,
    required TResult Function(UuidValue uuid, MediaStream stream) streamAdded,
    required TResult Function(UuidValue uuid, MediaStream stream) streamRemoved,
  }) {
    return streamAdded(uuid, stream);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult? Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult? Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamRemoved,
  }) {
    return streamAdded?.call(uuid, stream);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult Function(UuidValue uuid, MediaStream stream)? streamRemoved,
    required TResult orElse(),
  }) {
    if (streamAdded != null) {
      return streamAdded(uuid, stream);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PeerConnectionEventSignalingStateChanged value)
        signalingStateChanged,
    required TResult Function(_PeerConnectionEventConnectionStateChanged value)
        connectionStateChanged,
    required TResult Function(
            _PeerConnectionEventIceGatheringStateChanged value)
        iceGatheringStateChanged,
    required TResult Function(
            _PeerConnectionEventIceConnectionStateChanged value)
        iceConnectionStateChanged,
    required TResult Function(_PeerConnectionEventIceCandidateIdentified value)
        iceCandidateIdentified,
    required TResult Function(_PeerConnectionEventStreamAdded value)
        streamAdded,
    required TResult Function(_PeerConnectionEventStreamRemoved value)
        streamRemoved,
  }) {
    return streamAdded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult? Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult? Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult? Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult? Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult? Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult? Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
  }) {
    return streamAdded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
    required TResult orElse(),
  }) {
    if (streamAdded != null) {
      return streamAdded(this);
    }
    return orElse();
  }
}

abstract class _PeerConnectionEventStreamAdded implements _PeerConnectionEvent {
  const factory _PeerConnectionEventStreamAdded(
          final UuidValue uuid, final MediaStream stream) =
      _$PeerConnectionEventStreamAddedImpl;

  @override
  UuidValue get uuid;
  MediaStream get stream;
}

/// @nodoc

class _$PeerConnectionEventStreamRemovedImpl
    with DiagnosticableTreeMixin
    implements _PeerConnectionEventStreamRemoved {
  const _$PeerConnectionEventStreamRemovedImpl(this.uuid, this.stream);

  @override
  final UuidValue uuid;
  @override
  final MediaStream stream;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return '_PeerConnectionEvent.streamRemoved(uuid: $uuid, stream: $stream)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', '_PeerConnectionEvent.streamRemoved'))
      ..add(DiagnosticsProperty('uuid', uuid))
      ..add(DiagnosticsProperty('stream', stream));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PeerConnectionEventStreamRemovedImpl &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.stream, stream) || other.stream == stream));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uuid, stream);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UuidValue uuid, RTCSignalingState state)
        signalingStateChanged,
    required TResult Function(UuidValue uuid, RTCPeerConnectionState state)
        connectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceGatheringState state)
        iceGatheringStateChanged,
    required TResult Function(UuidValue uuid, RTCIceConnectionState state)
        iceConnectionStateChanged,
    required TResult Function(UuidValue uuid, RTCIceCandidate candidate)
        iceCandidateIdentified,
    required TResult Function(UuidValue uuid, MediaStream stream) streamAdded,
    required TResult Function(UuidValue uuid, MediaStream stream) streamRemoved,
  }) {
    return streamRemoved(uuid, stream);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult? Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult? Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult? Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult? Function(UuidValue uuid, MediaStream stream)? streamRemoved,
  }) {
    return streamRemoved?.call(uuid, stream);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UuidValue uuid, RTCSignalingState state)?
        signalingStateChanged,
    TResult Function(UuidValue uuid, RTCPeerConnectionState state)?
        connectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceGatheringState state)?
        iceGatheringStateChanged,
    TResult Function(UuidValue uuid, RTCIceConnectionState state)?
        iceConnectionStateChanged,
    TResult Function(UuidValue uuid, RTCIceCandidate candidate)?
        iceCandidateIdentified,
    TResult Function(UuidValue uuid, MediaStream stream)? streamAdded,
    TResult Function(UuidValue uuid, MediaStream stream)? streamRemoved,
    required TResult orElse(),
  }) {
    if (streamRemoved != null) {
      return streamRemoved(uuid, stream);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PeerConnectionEventSignalingStateChanged value)
        signalingStateChanged,
    required TResult Function(_PeerConnectionEventConnectionStateChanged value)
        connectionStateChanged,
    required TResult Function(
            _PeerConnectionEventIceGatheringStateChanged value)
        iceGatheringStateChanged,
    required TResult Function(
            _PeerConnectionEventIceConnectionStateChanged value)
        iceConnectionStateChanged,
    required TResult Function(_PeerConnectionEventIceCandidateIdentified value)
        iceCandidateIdentified,
    required TResult Function(_PeerConnectionEventStreamAdded value)
        streamAdded,
    required TResult Function(_PeerConnectionEventStreamRemoved value)
        streamRemoved,
  }) {
    return streamRemoved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult? Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult? Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult? Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult? Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult? Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult? Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
  }) {
    return streamRemoved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PeerConnectionEventSignalingStateChanged value)?
        signalingStateChanged,
    TResult Function(_PeerConnectionEventConnectionStateChanged value)?
        connectionStateChanged,
    TResult Function(_PeerConnectionEventIceGatheringStateChanged value)?
        iceGatheringStateChanged,
    TResult Function(_PeerConnectionEventIceConnectionStateChanged value)?
        iceConnectionStateChanged,
    TResult Function(_PeerConnectionEventIceCandidateIdentified value)?
        iceCandidateIdentified,
    TResult Function(_PeerConnectionEventStreamAdded value)? streamAdded,
    TResult Function(_PeerConnectionEventStreamRemoved value)? streamRemoved,
    required TResult orElse(),
  }) {
    if (streamRemoved != null) {
      return streamRemoved(this);
    }
    return orElse();
  }
}

abstract class _PeerConnectionEventStreamRemoved
    implements _PeerConnectionEvent {
  const factory _PeerConnectionEventStreamRemoved(
          final UuidValue uuid, final MediaStream stream) =
      _$PeerConnectionEventStreamRemovedImpl;

  @override
  UuidValue get uuid;
  MediaStream get stream;
}

/// @nodoc
mixin _$CallScreenEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() didPush,
    required TResult Function() didPop,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? didPush,
    TResult? Function()? didPop,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? didPush,
    TResult Function()? didPop,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallScreenEventDidPush value) didPush,
    required TResult Function(_CallScreenEventDidPop value) didPop,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallScreenEventDidPush value)? didPush,
    TResult? Function(_CallScreenEventDidPop value)? didPop,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallScreenEventDidPush value)? didPush,
    TResult Function(_CallScreenEventDidPop value)? didPop,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc

class _$CallScreenEventDidPushImpl
    with DiagnosticableTreeMixin
    implements _CallScreenEventDidPush {
  _$CallScreenEventDidPushImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallScreenEvent.didPush()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'CallScreenEvent.didPush'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallScreenEventDidPushImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() didPush,
    required TResult Function() didPop,
  }) {
    return didPush();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? didPush,
    TResult? Function()? didPop,
  }) {
    return didPush?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? didPush,
    TResult Function()? didPop,
    required TResult orElse(),
  }) {
    if (didPush != null) {
      return didPush();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallScreenEventDidPush value) didPush,
    required TResult Function(_CallScreenEventDidPop value) didPop,
  }) {
    return didPush(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallScreenEventDidPush value)? didPush,
    TResult? Function(_CallScreenEventDidPop value)? didPop,
  }) {
    return didPush?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallScreenEventDidPush value)? didPush,
    TResult Function(_CallScreenEventDidPop value)? didPop,
    required TResult orElse(),
  }) {
    if (didPush != null) {
      return didPush(this);
    }
    return orElse();
  }
}

abstract class _CallScreenEventDidPush implements CallScreenEvent {
  factory _CallScreenEventDidPush() = _$CallScreenEventDidPushImpl;
}

/// @nodoc

class _$CallScreenEventDidPopImpl
    with DiagnosticableTreeMixin
    implements _CallScreenEventDidPop {
  _$CallScreenEventDidPopImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallScreenEvent.didPop()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'CallScreenEvent.didPop'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallScreenEventDidPopImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() didPush,
    required TResult Function() didPop,
  }) {
    return didPop();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? didPush,
    TResult? Function()? didPop,
  }) {
    return didPop?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? didPush,
    TResult Function()? didPop,
    required TResult orElse(),
  }) {
    if (didPop != null) {
      return didPop();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CallScreenEventDidPush value) didPush,
    required TResult Function(_CallScreenEventDidPop value) didPop,
  }) {
    return didPop(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CallScreenEventDidPush value)? didPush,
    TResult? Function(_CallScreenEventDidPop value)? didPop,
  }) {
    return didPop?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CallScreenEventDidPush value)? didPush,
    TResult Function(_CallScreenEventDidPop value)? didPop,
    required TResult orElse(),
  }) {
    if (didPop != null) {
      return didPop(this);
    }
    return orElse();
  }
}

abstract class _CallScreenEventDidPop implements CallScreenEvent {
  factory _CallScreenEventDidPop() = _$CallScreenEventDidPopImpl;
}

/// @nodoc
mixin _$AccountRegisterEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getStatus,
    required TResult Function(bool value) changeStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getStatus,
    TResult? Function(bool value)? changeStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getStatus,
    TResult Function(bool value)? changeStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAccountRegistrationStatusEvent value)
        getStatus,
    required TResult Function(_ChangeAccountRegistrationStatusEvent value)
        changeStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetAccountRegistrationStatusEvent value)? getStatus,
    TResult? Function(_ChangeAccountRegistrationStatusEvent value)?
        changeStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAccountRegistrationStatusEvent value)? getStatus,
    TResult Function(_ChangeAccountRegistrationStatusEvent value)? changeStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc

class _$GetAccountRegistrationStatusEventImpl
    with DiagnosticableTreeMixin
    implements _GetAccountRegistrationStatusEvent {
  _$GetAccountRegistrationStatusEventImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AccountRegisterEvent.getStatus()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'AccountRegisterEvent.getStatus'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetAccountRegistrationStatusEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getStatus,
    required TResult Function(bool value) changeStatus,
  }) {
    return getStatus();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getStatus,
    TResult? Function(bool value)? changeStatus,
  }) {
    return getStatus?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getStatus,
    TResult Function(bool value)? changeStatus,
    required TResult orElse(),
  }) {
    if (getStatus != null) {
      return getStatus();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAccountRegistrationStatusEvent value)
        getStatus,
    required TResult Function(_ChangeAccountRegistrationStatusEvent value)
        changeStatus,
  }) {
    return getStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetAccountRegistrationStatusEvent value)? getStatus,
    TResult? Function(_ChangeAccountRegistrationStatusEvent value)?
        changeStatus,
  }) {
    return getStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAccountRegistrationStatusEvent value)? getStatus,
    TResult Function(_ChangeAccountRegistrationStatusEvent value)? changeStatus,
    required TResult orElse(),
  }) {
    if (getStatus != null) {
      return getStatus(this);
    }
    return orElse();
  }
}

abstract class _GetAccountRegistrationStatusEvent
    implements AccountRegisterEvent {
  factory _GetAccountRegistrationStatusEvent() =
      _$GetAccountRegistrationStatusEventImpl;
}

/// @nodoc

class _$ChangeAccountRegistrationStatusEventImpl
    with DiagnosticableTreeMixin
    implements _ChangeAccountRegistrationStatusEvent {
  _$ChangeAccountRegistrationStatusEventImpl(this.value);

  @override
  final bool value;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AccountRegisterEvent.changeStatus(value: $value)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AccountRegisterEvent.changeStatus'))
      ..add(DiagnosticsProperty('value', value));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangeAccountRegistrationStatusEventImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getStatus,
    required TResult Function(bool value) changeStatus,
  }) {
    return changeStatus(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getStatus,
    TResult? Function(bool value)? changeStatus,
  }) {
    return changeStatus?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getStatus,
    TResult Function(bool value)? changeStatus,
    required TResult orElse(),
  }) {
    if (changeStatus != null) {
      return changeStatus(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAccountRegistrationStatusEvent value)
        getStatus,
    required TResult Function(_ChangeAccountRegistrationStatusEvent value)
        changeStatus,
  }) {
    return changeStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetAccountRegistrationStatusEvent value)? getStatus,
    TResult? Function(_ChangeAccountRegistrationStatusEvent value)?
        changeStatus,
  }) {
    return changeStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAccountRegistrationStatusEvent value)? getStatus,
    TResult Function(_ChangeAccountRegistrationStatusEvent value)? changeStatus,
    required TResult orElse(),
  }) {
    if (changeStatus != null) {
      return changeStatus(this);
    }
    return orElse();
  }
}

abstract class _ChangeAccountRegistrationStatusEvent
    implements AccountRegisterEvent {
  factory _ChangeAccountRegistrationStatusEvent(final bool value) =
      _$ChangeAccountRegistrationStatusEventImpl;

  bool get value;
}

/// @nodoc
mixin _$CallState {
  RegisterAccountStatus get registerAccountStatus =>
      throw _privateConstructorUsedError;
  ConnectivityResult? get currentConnectivityResult =>
      throw _privateConstructorUsedError;
  SignalingClientStatus get signalingClientStatus =>
      throw _privateConstructorUsedError;
  Object? get lastSignalingClientConnectError =>
      throw _privateConstructorUsedError;
  Object? get lastSignalingClientDisconnectError =>
      throw _privateConstructorUsedError;
  int? get lastSignalingDisconnectCode => throw _privateConstructorUsedError;
  int get linesCount => throw _privateConstructorUsedError;
  List<ActiveCall> get activeCalls => throw _privateConstructorUsedError;
  bool? get minimized => throw _privateConstructorUsedError;
  bool? get speaker => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CallStateCopyWith<CallState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CallStateCopyWith<$Res> {
  factory $CallStateCopyWith(CallState value, $Res Function(CallState) then) =
      _$CallStateCopyWithImpl<$Res, CallState>;
  @useResult
  $Res call(
      {RegisterAccountStatus registerAccountStatus,
      ConnectivityResult? currentConnectivityResult,
      SignalingClientStatus signalingClientStatus,
      Object? lastSignalingClientConnectError,
      Object? lastSignalingClientDisconnectError,
      int? lastSignalingDisconnectCode,
      int linesCount,
      List<ActiveCall> activeCalls,
      bool? minimized,
      bool? speaker});
}

/// @nodoc
class _$CallStateCopyWithImpl<$Res, $Val extends CallState>
    implements $CallStateCopyWith<$Res> {
  _$CallStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? registerAccountStatus = null,
    Object? currentConnectivityResult = freezed,
    Object? signalingClientStatus = null,
    Object? lastSignalingClientConnectError = freezed,
    Object? lastSignalingClientDisconnectError = freezed,
    Object? lastSignalingDisconnectCode = freezed,
    Object? linesCount = null,
    Object? activeCalls = null,
    Object? minimized = freezed,
    Object? speaker = freezed,
  }) {
    return _then(_value.copyWith(
      registerAccountStatus: null == registerAccountStatus
          ? _value.registerAccountStatus
          : registerAccountStatus // ignore: cast_nullable_to_non_nullable
              as RegisterAccountStatus,
      currentConnectivityResult: freezed == currentConnectivityResult
          ? _value.currentConnectivityResult
          : currentConnectivityResult // ignore: cast_nullable_to_non_nullable
              as ConnectivityResult?,
      signalingClientStatus: null == signalingClientStatus
          ? _value.signalingClientStatus
          : signalingClientStatus // ignore: cast_nullable_to_non_nullable
              as SignalingClientStatus,
      lastSignalingClientConnectError:
          freezed == lastSignalingClientConnectError
              ? _value.lastSignalingClientConnectError
              : lastSignalingClientConnectError,
      lastSignalingClientDisconnectError:
          freezed == lastSignalingClientDisconnectError
              ? _value.lastSignalingClientDisconnectError
              : lastSignalingClientDisconnectError,
      lastSignalingDisconnectCode: freezed == lastSignalingDisconnectCode
          ? _value.lastSignalingDisconnectCode
          : lastSignalingDisconnectCode // ignore: cast_nullable_to_non_nullable
              as int?,
      linesCount: null == linesCount
          ? _value.linesCount
          : linesCount // ignore: cast_nullable_to_non_nullable
              as int,
      activeCalls: null == activeCalls
          ? _value.activeCalls
          : activeCalls // ignore: cast_nullable_to_non_nullable
              as List<ActiveCall>,
      minimized: freezed == minimized
          ? _value.minimized
          : minimized // ignore: cast_nullable_to_non_nullable
              as bool?,
      speaker: freezed == speaker
          ? _value.speaker
          : speaker // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CallStateImplCopyWith<$Res>
    implements $CallStateCopyWith<$Res> {
  factory _$$CallStateImplCopyWith(
          _$CallStateImpl value, $Res Function(_$CallStateImpl) then) =
      __$$CallStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {RegisterAccountStatus registerAccountStatus,
      ConnectivityResult? currentConnectivityResult,
      SignalingClientStatus signalingClientStatus,
      Object? lastSignalingClientConnectError,
      Object? lastSignalingClientDisconnectError,
      int? lastSignalingDisconnectCode,
      int linesCount,
      List<ActiveCall> activeCalls,
      bool? minimized,
      bool? speaker});
}

/// @nodoc
class __$$CallStateImplCopyWithImpl<$Res>
    extends _$CallStateCopyWithImpl<$Res, _$CallStateImpl>
    implements _$$CallStateImplCopyWith<$Res> {
  __$$CallStateImplCopyWithImpl(
      _$CallStateImpl _value, $Res Function(_$CallStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? registerAccountStatus = null,
    Object? currentConnectivityResult = freezed,
    Object? signalingClientStatus = null,
    Object? lastSignalingClientConnectError = freezed,
    Object? lastSignalingClientDisconnectError = freezed,
    Object? lastSignalingDisconnectCode = freezed,
    Object? linesCount = null,
    Object? activeCalls = null,
    Object? minimized = freezed,
    Object? speaker = freezed,
  }) {
    return _then(_$CallStateImpl(
      registerAccountStatus: null == registerAccountStatus
          ? _value.registerAccountStatus
          : registerAccountStatus // ignore: cast_nullable_to_non_nullable
              as RegisterAccountStatus,
      currentConnectivityResult: freezed == currentConnectivityResult
          ? _value.currentConnectivityResult
          : currentConnectivityResult // ignore: cast_nullable_to_non_nullable
              as ConnectivityResult?,
      signalingClientStatus: null == signalingClientStatus
          ? _value.signalingClientStatus
          : signalingClientStatus // ignore: cast_nullable_to_non_nullable
              as SignalingClientStatus,
      lastSignalingClientConnectError:
          freezed == lastSignalingClientConnectError
              ? _value.lastSignalingClientConnectError
              : lastSignalingClientConnectError,
      lastSignalingClientDisconnectError:
          freezed == lastSignalingClientDisconnectError
              ? _value.lastSignalingClientDisconnectError
              : lastSignalingClientDisconnectError,
      lastSignalingDisconnectCode: freezed == lastSignalingDisconnectCode
          ? _value.lastSignalingDisconnectCode
          : lastSignalingDisconnectCode // ignore: cast_nullable_to_non_nullable
              as int?,
      linesCount: null == linesCount
          ? _value.linesCount
          : linesCount // ignore: cast_nullable_to_non_nullable
              as int,
      activeCalls: null == activeCalls
          ? _value._activeCalls
          : activeCalls // ignore: cast_nullable_to_non_nullable
              as List<ActiveCall>,
      minimized: freezed == minimized
          ? _value.minimized
          : minimized // ignore: cast_nullable_to_non_nullable
              as bool?,
      speaker: freezed == speaker
          ? _value.speaker
          : speaker // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

class _$CallStateImpl extends _CallState with DiagnosticableTreeMixin {
  const _$CallStateImpl(
      {required this.registerAccountStatus,
      this.currentConnectivityResult,
      this.signalingClientStatus = SignalingClientStatus.disconnect,
      this.lastSignalingClientConnectError,
      this.lastSignalingClientDisconnectError,
      this.lastSignalingDisconnectCode,
      this.linesCount = 0,
      final List<ActiveCall> activeCalls = const [],
      this.minimized,
      this.speaker})
      : _activeCalls = activeCalls,
        super._();

  @override
  final RegisterAccountStatus registerAccountStatus;
  @override
  final ConnectivityResult? currentConnectivityResult;
  @override
  @JsonKey()
  final SignalingClientStatus signalingClientStatus;
  @override
  final Object? lastSignalingClientConnectError;
  @override
  final Object? lastSignalingClientDisconnectError;
  @override
  final int? lastSignalingDisconnectCode;
  @override
  @JsonKey()
  final int linesCount;
  final List<ActiveCall> _activeCalls;
  @override
  @JsonKey()
  List<ActiveCall> get activeCalls {
    if (_activeCalls is EqualUnmodifiableListView) return _activeCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_activeCalls);
  }

  @override
  final bool? minimized;
  @override
  final bool? speaker;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CallState(registerAccountStatus: $registerAccountStatus, currentConnectivityResult: $currentConnectivityResult, signalingClientStatus: $signalingClientStatus, lastSignalingClientConnectError: $lastSignalingClientConnectError, lastSignalingClientDisconnectError: $lastSignalingClientDisconnectError, lastSignalingDisconnectCode: $lastSignalingDisconnectCode, linesCount: $linesCount, activeCalls: $activeCalls, minimized: $minimized, speaker: $speaker)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CallState'))
      ..add(DiagnosticsProperty('registerAccountStatus', registerAccountStatus))
      ..add(DiagnosticsProperty(
          'currentConnectivityResult', currentConnectivityResult))
      ..add(DiagnosticsProperty('signalingClientStatus', signalingClientStatus))
      ..add(DiagnosticsProperty(
          'lastSignalingClientConnectError', lastSignalingClientConnectError))
      ..add(DiagnosticsProperty('lastSignalingClientDisconnectError',
          lastSignalingClientDisconnectError))
      ..add(DiagnosticsProperty(
          'lastSignalingDisconnectCode', lastSignalingDisconnectCode))
      ..add(DiagnosticsProperty('linesCount', linesCount))
      ..add(DiagnosticsProperty('activeCalls', activeCalls))
      ..add(DiagnosticsProperty('minimized', minimized))
      ..add(DiagnosticsProperty('speaker', speaker));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CallStateImpl &&
            (identical(other.registerAccountStatus, registerAccountStatus) ||
                other.registerAccountStatus == registerAccountStatus) &&
            (identical(other.currentConnectivityResult,
                    currentConnectivityResult) ||
                other.currentConnectivityResult == currentConnectivityResult) &&
            (identical(other.signalingClientStatus, signalingClientStatus) ||
                other.signalingClientStatus == signalingClientStatus) &&
            const DeepCollectionEquality().equals(
                other.lastSignalingClientConnectError,
                lastSignalingClientConnectError) &&
            const DeepCollectionEquality().equals(
                other.lastSignalingClientDisconnectError,
                lastSignalingClientDisconnectError) &&
            (identical(other.lastSignalingDisconnectCode,
                    lastSignalingDisconnectCode) ||
                other.lastSignalingDisconnectCode ==
                    lastSignalingDisconnectCode) &&
            (identical(other.linesCount, linesCount) ||
                other.linesCount == linesCount) &&
            const DeepCollectionEquality()
                .equals(other._activeCalls, _activeCalls) &&
            (identical(other.minimized, minimized) ||
                other.minimized == minimized) &&
            (identical(other.speaker, speaker) || other.speaker == speaker));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      registerAccountStatus,
      currentConnectivityResult,
      signalingClientStatus,
      const DeepCollectionEquality().hash(lastSignalingClientConnectError),
      const DeepCollectionEquality().hash(lastSignalingClientDisconnectError),
      lastSignalingDisconnectCode,
      linesCount,
      const DeepCollectionEquality().hash(_activeCalls),
      minimized,
      speaker);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CallStateImplCopyWith<_$CallStateImpl> get copyWith =>
      __$$CallStateImplCopyWithImpl<_$CallStateImpl>(this, _$identity);
}

abstract class _CallState extends CallState {
  const factory _CallState(
      {required final RegisterAccountStatus registerAccountStatus,
      final ConnectivityResult? currentConnectivityResult,
      final SignalingClientStatus signalingClientStatus,
      final Object? lastSignalingClientConnectError,
      final Object? lastSignalingClientDisconnectError,
      final int? lastSignalingDisconnectCode,
      final int linesCount,
      final List<ActiveCall> activeCalls,
      final bool? minimized,
      final bool? speaker}) = _$CallStateImpl;
  const _CallState._() : super._();

  @override
  RegisterAccountStatus get registerAccountStatus;
  @override
  ConnectivityResult? get currentConnectivityResult;
  @override
  SignalingClientStatus get signalingClientStatus;
  @override
  Object? get lastSignalingClientConnectError;
  @override
  Object? get lastSignalingClientDisconnectError;
  @override
  int? get lastSignalingDisconnectCode;
  @override
  int get linesCount;
  @override
  List<ActiveCall> get activeCalls;
  @override
  bool? get minimized;
  @override
  bool? get speaker;
  @override
  @JsonKey(ignore: true)
  _$$CallStateImplCopyWith<_$CallStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ActiveCall {
  Direction get direction => throw _privateConstructorUsedError;
  int get line => throw _privateConstructorUsedError;
  CallIdValue get callId => throw _privateConstructorUsedError;
  CallkeepHandle get handle => throw _privateConstructorUsedError;
  String? get displayName => throw _privateConstructorUsedError;
  bool get video => throw _privateConstructorUsedError;
  bool? get frontCamera => throw _privateConstructorUsedError;
  bool get held => throw _privateConstructorUsedError;
  bool get muted => throw _privateConstructorUsedError;
  bool get updating => throw _privateConstructorUsedError;
  DateTime get createdTime => throw _privateConstructorUsedError;
  DateTime? get acceptedTime => throw _privateConstructorUsedError;
  DateTime? get hungUpTime => throw _privateConstructorUsedError;
  Transfer? get transfer => throw _privateConstructorUsedError;
  Object? get failure => throw _privateConstructorUsedError;
  RTCVideoRenderers get renderers => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ActiveCallCopyWith<ActiveCall> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ActiveCallCopyWith<$Res> {
  factory $ActiveCallCopyWith(
          ActiveCall value, $Res Function(ActiveCall) then) =
      _$ActiveCallCopyWithImpl<$Res, ActiveCall>;
  @useResult
  $Res call(
      {Direction direction,
      int line,
      CallIdValue callId,
      CallkeepHandle handle,
      String? displayName,
      bool video,
      bool? frontCamera,
      bool held,
      bool muted,
      bool updating,
      DateTime createdTime,
      DateTime? acceptedTime,
      DateTime? hungUpTime,
      Transfer? transfer,
      Object? failure,
      RTCVideoRenderers renderers});
}

/// @nodoc
class _$ActiveCallCopyWithImpl<$Res, $Val extends ActiveCall>
    implements $ActiveCallCopyWith<$Res> {
  _$ActiveCallCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? direction = null,
    Object? line = null,
    Object? callId = null,
    Object? handle = null,
    Object? displayName = freezed,
    Object? video = null,
    Object? frontCamera = freezed,
    Object? held = null,
    Object? muted = null,
    Object? updating = null,
    Object? createdTime = null,
    Object? acceptedTime = freezed,
    Object? hungUpTime = freezed,
    Object? transfer = freezed,
    Object? failure = freezed,
    Object? renderers = null,
  }) {
    return _then(_value.copyWith(
      direction: null == direction
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as Direction,
      line: null == line
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as int,
      callId: null == callId
          ? _value.callId
          : callId // ignore: cast_nullable_to_non_nullable
              as CallIdValue,
      handle: null == handle
          ? _value.handle
          : handle // ignore: cast_nullable_to_non_nullable
              as CallkeepHandle,
      displayName: freezed == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      video: null == video
          ? _value.video
          : video // ignore: cast_nullable_to_non_nullable
              as bool,
      frontCamera: freezed == frontCamera
          ? _value.frontCamera
          : frontCamera // ignore: cast_nullable_to_non_nullable
              as bool?,
      held: null == held
          ? _value.held
          : held // ignore: cast_nullable_to_non_nullable
              as bool,
      muted: null == muted
          ? _value.muted
          : muted // ignore: cast_nullable_to_non_nullable
              as bool,
      updating: null == updating
          ? _value.updating
          : updating // ignore: cast_nullable_to_non_nullable
              as bool,
      createdTime: null == createdTime
          ? _value.createdTime
          : createdTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      acceptedTime: freezed == acceptedTime
          ? _value.acceptedTime
          : acceptedTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      hungUpTime: freezed == hungUpTime
          ? _value.hungUpTime
          : hungUpTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      transfer: freezed == transfer
          ? _value.transfer
          : transfer // ignore: cast_nullable_to_non_nullable
              as Transfer?,
      failure: freezed == failure ? _value.failure : failure,
      renderers: null == renderers
          ? _value.renderers
          : renderers // ignore: cast_nullable_to_non_nullable
              as RTCVideoRenderers,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ActiveCallImplCopyWith<$Res>
    implements $ActiveCallCopyWith<$Res> {
  factory _$$ActiveCallImplCopyWith(
          _$ActiveCallImpl value, $Res Function(_$ActiveCallImpl) then) =
      __$$ActiveCallImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Direction direction,
      int line,
      CallIdValue callId,
      CallkeepHandle handle,
      String? displayName,
      bool video,
      bool? frontCamera,
      bool held,
      bool muted,
      bool updating,
      DateTime createdTime,
      DateTime? acceptedTime,
      DateTime? hungUpTime,
      Transfer? transfer,
      Object? failure,
      RTCVideoRenderers renderers});
}

/// @nodoc
class __$$ActiveCallImplCopyWithImpl<$Res>
    extends _$ActiveCallCopyWithImpl<$Res, _$ActiveCallImpl>
    implements _$$ActiveCallImplCopyWith<$Res> {
  __$$ActiveCallImplCopyWithImpl(
      _$ActiveCallImpl _value, $Res Function(_$ActiveCallImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? direction = null,
    Object? line = null,
    Object? callId = null,
    Object? handle = null,
    Object? displayName = freezed,
    Object? video = null,
    Object? frontCamera = freezed,
    Object? held = null,
    Object? muted = null,
    Object? updating = null,
    Object? createdTime = null,
    Object? acceptedTime = freezed,
    Object? hungUpTime = freezed,
    Object? transfer = freezed,
    Object? failure = freezed,
    Object? renderers = null,
  }) {
    return _then(_$ActiveCallImpl(
      direction: null == direction
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as Direction,
      line: null == line
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as int,
      callId: null == callId
          ? _value.callId
          : callId // ignore: cast_nullable_to_non_nullable
              as CallIdValue,
      handle: null == handle
          ? _value.handle
          : handle // ignore: cast_nullable_to_non_nullable
              as CallkeepHandle,
      displayName: freezed == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      video: null == video
          ? _value.video
          : video // ignore: cast_nullable_to_non_nullable
              as bool,
      frontCamera: freezed == frontCamera
          ? _value.frontCamera
          : frontCamera // ignore: cast_nullable_to_non_nullable
              as bool?,
      held: null == held
          ? _value.held
          : held // ignore: cast_nullable_to_non_nullable
              as bool,
      muted: null == muted
          ? _value.muted
          : muted // ignore: cast_nullable_to_non_nullable
              as bool,
      updating: null == updating
          ? _value.updating
          : updating // ignore: cast_nullable_to_non_nullable
              as bool,
      createdTime: null == createdTime
          ? _value.createdTime
          : createdTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      acceptedTime: freezed == acceptedTime
          ? _value.acceptedTime
          : acceptedTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      hungUpTime: freezed == hungUpTime
          ? _value.hungUpTime
          : hungUpTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      transfer: freezed == transfer
          ? _value.transfer
          : transfer // ignore: cast_nullable_to_non_nullable
              as Transfer?,
      failure: freezed == failure ? _value.failure : failure,
      renderers: null == renderers
          ? _value.renderers
          : renderers // ignore: cast_nullable_to_non_nullable
              as RTCVideoRenderers,
    ));
  }
}

/// @nodoc

class _$ActiveCallImpl extends _ActiveCall with DiagnosticableTreeMixin {
  _$ActiveCallImpl(
      {required this.direction,
      required this.line,
      required this.callId,
      required this.handle,
      this.displayName,
      required this.video,
      this.frontCamera = true,
      this.held = false,
      this.muted = false,
      this.updating = false,
      required this.createdTime,
      this.acceptedTime,
      this.hungUpTime,
      this.transfer,
      this.failure,
      required this.renderers})
      : super._();

  @override
  final Direction direction;
  @override
  final int line;
  @override
  final CallIdValue callId;
  @override
  final CallkeepHandle handle;
  @override
  final String? displayName;
  @override
  final bool video;
  @override
  @JsonKey()
  final bool? frontCamera;
  @override
  @JsonKey()
  final bool held;
  @override
  @JsonKey()
  final bool muted;
  @override
  @JsonKey()
  final bool updating;
  @override
  final DateTime createdTime;
  @override
  final DateTime? acceptedTime;
  @override
  final DateTime? hungUpTime;
  @override
  final Transfer? transfer;
  @override
  final Object? failure;
  @override
  final RTCVideoRenderers renderers;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ActiveCall(direction: $direction, line: $line, callId: $callId, handle: $handle, displayName: $displayName, video: $video, frontCamera: $frontCamera, held: $held, muted: $muted, updating: $updating, createdTime: $createdTime, acceptedTime: $acceptedTime, hungUpTime: $hungUpTime, transfer: $transfer, failure: $failure, renderers: $renderers)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ActiveCall'))
      ..add(DiagnosticsProperty('direction', direction))
      ..add(DiagnosticsProperty('line', line))
      ..add(DiagnosticsProperty('callId', callId))
      ..add(DiagnosticsProperty('handle', handle))
      ..add(DiagnosticsProperty('displayName', displayName))
      ..add(DiagnosticsProperty('video', video))
      ..add(DiagnosticsProperty('frontCamera', frontCamera))
      ..add(DiagnosticsProperty('held', held))
      ..add(DiagnosticsProperty('muted', muted))
      ..add(DiagnosticsProperty('updating', updating))
      ..add(DiagnosticsProperty('createdTime', createdTime))
      ..add(DiagnosticsProperty('acceptedTime', acceptedTime))
      ..add(DiagnosticsProperty('hungUpTime', hungUpTime))
      ..add(DiagnosticsProperty('transfer', transfer))
      ..add(DiagnosticsProperty('failure', failure))
      ..add(DiagnosticsProperty('renderers', renderers));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ActiveCallImpl &&
            (identical(other.direction, direction) ||
                other.direction == direction) &&
            (identical(other.line, line) || other.line == line) &&
            (identical(other.callId, callId) || other.callId == callId) &&
            (identical(other.handle, handle) || other.handle == handle) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.video, video) || other.video == video) &&
            (identical(other.frontCamera, frontCamera) ||
                other.frontCamera == frontCamera) &&
            (identical(other.held, held) || other.held == held) &&
            (identical(other.muted, muted) || other.muted == muted) &&
            (identical(other.updating, updating) ||
                other.updating == updating) &&
            (identical(other.createdTime, createdTime) ||
                other.createdTime == createdTime) &&
            (identical(other.acceptedTime, acceptedTime) ||
                other.acceptedTime == acceptedTime) &&
            (identical(other.hungUpTime, hungUpTime) ||
                other.hungUpTime == hungUpTime) &&
            (identical(other.transfer, transfer) ||
                other.transfer == transfer) &&
            const DeepCollectionEquality().equals(other.failure, failure) &&
            (identical(other.renderers, renderers) ||
                other.renderers == renderers));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      direction,
      line,
      callId,
      handle,
      displayName,
      video,
      frontCamera,
      held,
      muted,
      updating,
      createdTime,
      acceptedTime,
      hungUpTime,
      transfer,
      const DeepCollectionEquality().hash(failure),
      renderers);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ActiveCallImplCopyWith<_$ActiveCallImpl> get copyWith =>
      __$$ActiveCallImplCopyWithImpl<_$ActiveCallImpl>(this, _$identity);
}

abstract class _ActiveCall extends ActiveCall {
  factory _ActiveCall(
      {required final Direction direction,
      required final int line,
      required final CallIdValue callId,
      required final CallkeepHandle handle,
      final String? displayName,
      required final bool video,
      final bool? frontCamera,
      final bool held,
      final bool muted,
      final bool updating,
      required final DateTime createdTime,
      final DateTime? acceptedTime,
      final DateTime? hungUpTime,
      final Transfer? transfer,
      final Object? failure,
      required final RTCVideoRenderers renderers}) = _$ActiveCallImpl;
  _ActiveCall._() : super._();

  @override
  Direction get direction;
  @override
  int get line;
  @override
  CallIdValue get callId;
  @override
  CallkeepHandle get handle;
  @override
  String? get displayName;
  @override
  bool get video;
  @override
  bool? get frontCamera;
  @override
  bool get held;
  @override
  bool get muted;
  @override
  bool get updating;
  @override
  DateTime get createdTime;
  @override
  DateTime? get acceptedTime;
  @override
  DateTime? get hungUpTime;
  @override
  Transfer? get transfer;
  @override
  Object? get failure;
  @override
  RTCVideoRenderers get renderers;
  @override
  @JsonKey(ignore: true)
  _$$ActiveCallImplCopyWith<_$ActiveCallImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RegisterAccountStatus {
  bool? get registerStatus => throw _privateConstructorUsedError;
  bool? get progress => throw _privateConstructorUsedError;
}

/// @nodoc

class _$RegisterAccountStatusImpl extends _RegisterAccountStatus
    with DiagnosticableTreeMixin {
  const _$RegisterAccountStatusImpl({this.registerStatus, this.progress})
      : super._();

  @override
  final bool? registerStatus;
  @override
  final bool? progress;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RegisterAccountStatus(registerStatus: $registerStatus, progress: $progress)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'RegisterAccountStatus'))
      ..add(DiagnosticsProperty('registerStatus', registerStatus))
      ..add(DiagnosticsProperty('progress', progress));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RegisterAccountStatusImpl &&
            (identical(other.registerStatus, registerStatus) ||
                other.registerStatus == registerStatus) &&
            (identical(other.progress, progress) ||
                other.progress == progress));
  }

  @override
  int get hashCode => Object.hash(runtimeType, registerStatus, progress);
}

abstract class _RegisterAccountStatus extends RegisterAccountStatus {
  const factory _RegisterAccountStatus(
      {final bool? registerStatus,
      final bool? progress}) = _$RegisterAccountStatusImpl;
  const _RegisterAccountStatus._() : super._();

  @override
  bool? get registerStatus;
  @override
  bool? get progress;
}
