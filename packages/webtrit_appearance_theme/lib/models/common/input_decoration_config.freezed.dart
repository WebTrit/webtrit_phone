// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'input_decoration_config.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$InputDecorationConfig {

 String? get hintText; TextStyleConfig? get hintStyle; String? get labelText; TextStyleConfig? get labelStyle; String? get helperText; TextStyleConfig? get helperStyle; TextStyleConfig? get errorStyle; String? get prefixText; TextStyleConfig? get prefixStyle; String? get suffixText; TextStyleConfig? get suffixStyle; String? get fillColor; bool? get filled; BorderConfig? get border; BorderConfig? get enabledBorder; BorderConfig? get focusedBorder; BorderConfig? get errorBorder; BorderConfig? get focusedErrorBorder; BorderConfig? get disabledBorder;
/// Create a copy of InputDecorationConfig
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InputDecorationConfigCopyWith<InputDecorationConfig> get copyWith => _$InputDecorationConfigCopyWithImpl<InputDecorationConfig>(this as InputDecorationConfig, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InputDecorationConfig&&(identical(other.hintText, hintText) || other.hintText == hintText)&&(identical(other.hintStyle, hintStyle) || other.hintStyle == hintStyle)&&(identical(other.labelText, labelText) || other.labelText == labelText)&&(identical(other.labelStyle, labelStyle) || other.labelStyle == labelStyle)&&(identical(other.helperText, helperText) || other.helperText == helperText)&&(identical(other.helperStyle, helperStyle) || other.helperStyle == helperStyle)&&(identical(other.errorStyle, errorStyle) || other.errorStyle == errorStyle)&&(identical(other.prefixText, prefixText) || other.prefixText == prefixText)&&(identical(other.prefixStyle, prefixStyle) || other.prefixStyle == prefixStyle)&&(identical(other.suffixText, suffixText) || other.suffixText == suffixText)&&(identical(other.suffixStyle, suffixStyle) || other.suffixStyle == suffixStyle)&&(identical(other.fillColor, fillColor) || other.fillColor == fillColor)&&(identical(other.filled, filled) || other.filled == filled)&&(identical(other.border, border) || other.border == border)&&(identical(other.enabledBorder, enabledBorder) || other.enabledBorder == enabledBorder)&&(identical(other.focusedBorder, focusedBorder) || other.focusedBorder == focusedBorder)&&(identical(other.errorBorder, errorBorder) || other.errorBorder == errorBorder)&&(identical(other.focusedErrorBorder, focusedErrorBorder) || other.focusedErrorBorder == focusedErrorBorder)&&(identical(other.disabledBorder, disabledBorder) || other.disabledBorder == disabledBorder));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,hintText,hintStyle,labelText,labelStyle,helperText,helperStyle,errorStyle,prefixText,prefixStyle,suffixText,suffixStyle,fillColor,filled,border,enabledBorder,focusedBorder,errorBorder,focusedErrorBorder,disabledBorder]);

@override
String toString() {
  return 'InputDecorationConfig(hintText: $hintText, hintStyle: $hintStyle, labelText: $labelText, labelStyle: $labelStyle, helperText: $helperText, helperStyle: $helperStyle, errorStyle: $errorStyle, prefixText: $prefixText, prefixStyle: $prefixStyle, suffixText: $suffixText, suffixStyle: $suffixStyle, fillColor: $fillColor, filled: $filled, border: $border, enabledBorder: $enabledBorder, focusedBorder: $focusedBorder, errorBorder: $errorBorder, focusedErrorBorder: $focusedErrorBorder, disabledBorder: $disabledBorder)';
}


}

/// @nodoc
abstract mixin class $InputDecorationConfigCopyWith<$Res>  {
  factory $InputDecorationConfigCopyWith(InputDecorationConfig value, $Res Function(InputDecorationConfig) _then) = _$InputDecorationConfigCopyWithImpl;
@useResult
$Res call({
 String? hintText, TextStyleConfig? hintStyle, String? labelText, TextStyleConfig? labelStyle, String? helperText, TextStyleConfig? helperStyle, TextStyleConfig? errorStyle, String? prefixText, TextStyleConfig? prefixStyle, String? suffixText, TextStyleConfig? suffixStyle, String? fillColor, bool? filled, BorderConfig? border, BorderConfig? enabledBorder, BorderConfig? focusedBorder, BorderConfig? errorBorder, BorderConfig? focusedErrorBorder, BorderConfig? disabledBorder
});




}
/// @nodoc
class _$InputDecorationConfigCopyWithImpl<$Res>
    implements $InputDecorationConfigCopyWith<$Res> {
  _$InputDecorationConfigCopyWithImpl(this._self, this._then);

  final InputDecorationConfig _self;
  final $Res Function(InputDecorationConfig) _then;

/// Create a copy of InputDecorationConfig
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? hintText = freezed,Object? hintStyle = freezed,Object? labelText = freezed,Object? labelStyle = freezed,Object? helperText = freezed,Object? helperStyle = freezed,Object? errorStyle = freezed,Object? prefixText = freezed,Object? prefixStyle = freezed,Object? suffixText = freezed,Object? suffixStyle = freezed,Object? fillColor = freezed,Object? filled = freezed,Object? border = freezed,Object? enabledBorder = freezed,Object? focusedBorder = freezed,Object? errorBorder = freezed,Object? focusedErrorBorder = freezed,Object? disabledBorder = freezed,}) {
  return _then(InputDecorationConfig(
hintText: freezed == hintText ? _self.hintText : hintText // ignore: cast_nullable_to_non_nullable
as String?,hintStyle: freezed == hintStyle ? _self.hintStyle : hintStyle // ignore: cast_nullable_to_non_nullable
as TextStyleConfig?,labelText: freezed == labelText ? _self.labelText : labelText // ignore: cast_nullable_to_non_nullable
as String?,labelStyle: freezed == labelStyle ? _self.labelStyle : labelStyle // ignore: cast_nullable_to_non_nullable
as TextStyleConfig?,helperText: freezed == helperText ? _self.helperText : helperText // ignore: cast_nullable_to_non_nullable
as String?,helperStyle: freezed == helperStyle ? _self.helperStyle : helperStyle // ignore: cast_nullable_to_non_nullable
as TextStyleConfig?,errorStyle: freezed == errorStyle ? _self.errorStyle : errorStyle // ignore: cast_nullable_to_non_nullable
as TextStyleConfig?,prefixText: freezed == prefixText ? _self.prefixText : prefixText // ignore: cast_nullable_to_non_nullable
as String?,prefixStyle: freezed == prefixStyle ? _self.prefixStyle : prefixStyle // ignore: cast_nullable_to_non_nullable
as TextStyleConfig?,suffixText: freezed == suffixText ? _self.suffixText : suffixText // ignore: cast_nullable_to_non_nullable
as String?,suffixStyle: freezed == suffixStyle ? _self.suffixStyle : suffixStyle // ignore: cast_nullable_to_non_nullable
as TextStyleConfig?,fillColor: freezed == fillColor ? _self.fillColor : fillColor // ignore: cast_nullable_to_non_nullable
as String?,filled: freezed == filled ? _self.filled : filled // ignore: cast_nullable_to_non_nullable
as bool?,border: freezed == border ? _self.border : border // ignore: cast_nullable_to_non_nullable
as BorderConfig?,enabledBorder: freezed == enabledBorder ? _self.enabledBorder : enabledBorder // ignore: cast_nullable_to_non_nullable
as BorderConfig?,focusedBorder: freezed == focusedBorder ? _self.focusedBorder : focusedBorder // ignore: cast_nullable_to_non_nullable
as BorderConfig?,errorBorder: freezed == errorBorder ? _self.errorBorder : errorBorder // ignore: cast_nullable_to_non_nullable
as BorderConfig?,focusedErrorBorder: freezed == focusedErrorBorder ? _self.focusedErrorBorder : focusedErrorBorder // ignore: cast_nullable_to_non_nullable
as BorderConfig?,disabledBorder: freezed == disabledBorder ? _self.disabledBorder : disabledBorder // ignore: cast_nullable_to_non_nullable
as BorderConfig?,
  ));
}

}


/// Adds pattern-matching-related methods to [InputDecorationConfig].
extension InputDecorationConfigPatterns on InputDecorationConfig {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({required TResult orElse(),}){
final _that = this;
switch (_that) {
case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(){
final _that = this;
switch (_that) {
case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(){
final _that = this;
switch (_that) {
case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({required TResult orElse(),}) {final _that = this;
switch (_that) {
case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>() {final _that = this;
switch (_that) {
case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>() {final _that = this;
switch (_that) {
case _:
  return null;

}
}

}


/// @nodoc
mixin _$BorderConfig {

 String get type; double? get borderRadius; String? get borderColor; double? get borderWidth;
/// Create a copy of BorderConfig
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BorderConfigCopyWith<BorderConfig> get copyWith => _$BorderConfigCopyWithImpl<BorderConfig>(this as BorderConfig, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BorderConfig&&(identical(other.type, type) || other.type == type)&&(identical(other.borderRadius, borderRadius) || other.borderRadius == borderRadius)&&(identical(other.borderColor, borderColor) || other.borderColor == borderColor)&&(identical(other.borderWidth, borderWidth) || other.borderWidth == borderWidth));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,type,borderRadius,borderColor,borderWidth);

@override
String toString() {
  return 'BorderConfig(type: $type, borderRadius: $borderRadius, borderColor: $borderColor, borderWidth: $borderWidth)';
}


}

/// @nodoc
abstract mixin class $BorderConfigCopyWith<$Res>  {
  factory $BorderConfigCopyWith(BorderConfig value, $Res Function(BorderConfig) _then) = _$BorderConfigCopyWithImpl;
@useResult
$Res call({
 String type, double? borderRadius, String? borderColor, double? borderWidth
});




}
/// @nodoc
class _$BorderConfigCopyWithImpl<$Res>
    implements $BorderConfigCopyWith<$Res> {
  _$BorderConfigCopyWithImpl(this._self, this._then);

  final BorderConfig _self;
  final $Res Function(BorderConfig) _then;

/// Create a copy of BorderConfig
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? type = null,Object? borderRadius = freezed,Object? borderColor = freezed,Object? borderWidth = freezed,}) {
  return _then(BorderConfig(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as String,borderRadius: freezed == borderRadius ? _self.borderRadius : borderRadius // ignore: cast_nullable_to_non_nullable
as double?,borderColor: freezed == borderColor ? _self.borderColor : borderColor // ignore: cast_nullable_to_non_nullable
as String?,borderWidth: freezed == borderWidth ? _self.borderWidth : borderWidth // ignore: cast_nullable_to_non_nullable
as double?,
  ));
}

}


/// Adds pattern-matching-related methods to [BorderConfig].
extension BorderConfigPatterns on BorderConfig {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({required TResult orElse(),}){
final _that = this;
switch (_that) {
case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(){
final _that = this;
switch (_that) {
case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(){
final _that = this;
switch (_that) {
case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({required TResult orElse(),}) {final _that = this;
switch (_that) {
case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>() {final _that = this;
switch (_that) {
case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>() {final _that = this;
switch (_that) {
case _:
  return null;

}
}

}

// dart format on
